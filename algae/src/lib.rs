//! # Algae - Algebraic Effects for Rust
//!
//! Algae is a library for algebraic effects in Rust, providing a way to write effectful
//! computations in a composable and testable manner. Algebraic effects allow you to
//! separate the description of side effects from their implementation, making your code
//! more modular and easier to test.
//!
//! ## One-Shot (Linear) Effects
//!
//! Algae implements **one-shot (linear) algebraic effects**, where each effect operation
//! receives exactly one response and continuations are not captured for reuse. This design
//! provides several benefits:
//!
//! - **Simplicity**: Easier to understand and debug than multi-shot alternatives
//! - **Performance**: No continuation capture overhead
//! - **Predictability**: Linear control flow is easier to reason about
//! - **Rust-Friendly**: Aligns well with Rust's ownership model
//!
//! This covers the vast majority of real-world use cases including I/O, state management,
//! logging, error handling, and resource management.
//!
//! ## Core Concepts
//!
//! - **Effects**: Descriptions of operations that can be performed (e.g., "read a file", "log a message")
//! - **Handlers**: Implementations that define how effects are executed
//! - **Effectful Functions**: Functions that can perform effects using the `perform!` macro
//!
//! ## Quick Start
//!
//! ```rust,ignore
//! #![feature(coroutines, coroutine_trait, yield_expr)]
//! use algae::prelude::*;
//!
//! // Define your effects
//! effect! {
//!     Console::Print (String) -> ();
//!     Console::ReadLine -> String;
//! }
//!
//! // Write effectful functions
//! #[effectful]
//! fn greet_user() -> String {
//!     let _: () = perform!(Console::Print("What's your name?".to_string()));
//!     let name: String = perform!(Console::ReadLine);
//!     format!("Hello, {}!", name)
//! }
//!
//! // Implement handlers
//! struct MockConsole {
//!     responses: Vec<String>,
//!     index: std::cell::RefCell<usize>,
//! }
//!
//! impl Handler<Op> for MockConsole {
//!     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
//!         match op {
//!             Op::Console(Console::Print(msg)) => {
//!                 println!("[MOCK] {}", msg);
//!                 Box::new(())
//!             }
//!             Op::Console(Console::ReadLine) => {
//!                 let mut index = self.index.borrow_mut();
//!                 let response = self.responses.get(*index).cloned()
//!                     .unwrap_or_else(|| "default".to_string());
//!                 *index += 1;
//!                 Box::new(response)
//!             }
//!         }
//!     }
//! }
//!
//! // Run with handler
//! let handler = MockConsole {
//!     responses: vec!["Alice".to_string()],
//!     index: std::cell::RefCell::new(0),
//! };
//! let result = greet_user().handle(handler).run();
//! assert_eq!(result, "Hello, Alice!");
//! ```
//!
//! ## Features
//!
//! - **Type-safe effects**: Effects are statically typed and checked at compile time
//! - **Composable handlers**: Multiple effect families can be handled by a single handler
//! - **Testable**: Effects can be easily mocked for testing
//! - **Zero-cost abstractions**: Minimal runtime overhead
//! - **Rust coroutines**: Built on Rust's native coroutine support

#![feature(coroutines, coroutine_trait)]
use std::{
    any::Any,
    ops::{Coroutine, CoroutineState},
    pin::Pin,
};

/// An effect operation request paired with a slot for the handler's reply.
///
/// An `Effect` represents a single effectful operation that has been yielded from
/// an effectful computation. It contains the operation description (`op`) and a
/// slot where the handler can store the result of processing that operation.
///
/// ## One-Shot Semantics
///
/// Effects in algae are **one-shot (linear)**, meaning:
/// - Each effect receives exactly **one response** from the handler
/// - The effect is **consumed** when the reply is extracted
/// - **No continuation capture** - the computation cannot be rewound or replayed
/// - **Linear control flow** - effects execute once and continue forward
///
/// This design ensures predictable behavior and optimal performance while covering
/// the vast majority of practical use cases.
///
/// # Type Parameters
///
/// * `Op` - The type representing the effect operation. This is typically an enum
///   generated by the `effect!` macro that describes all possible operations.
///
/// # Fields
///
/// * `op` - The operation being requested (e.g., "read file", "log message")
/// * `reply` - A type-erased storage slot where the handler places the result (filled exactly once)
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// // Effects are typically created by the perform! macro and handled automatically
/// let mut effect = Effect::new(Test::GetValue);
/// effect.fill_boxed(Box::new(42i32));
/// let reply = effect.get_reply();
/// let value: i32 = reply.take();
/// assert_eq!(value, 42);
/// ```
pub struct Effect<Op: 'static> {
    /// The operation being requested
    pub op: Op,
    /// Storage for the handler's reply (filled by the handler)
    reply: Option<Box<dyn Any + Send>>,
}

/// A type-erased container for handler replies that can be safely extracted.
///
/// A `Reply` holds the result from a handler after it processes an effect operation.
/// The value is stored in a type-erased `Box<dyn Any + Send>` but can be safely
/// extracted with the correct type using the `take` method.
///
/// ## One-Shot Extraction
///
/// Consistent with algae's one-shot effect model, replies can only be extracted **once**.
/// The `take` method consumes the `Reply`, ensuring that each handler response is used
/// exactly once, maintaining linear control flow and preventing accidental reuse.
///
/// # Safety
///
/// The type safety is ensured by the effect system - handlers are expected to
/// return values of the correct type as specified in the effect definition.
/// Runtime type checking occurs during extraction to catch any mismatches.
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         Box::new(42i32)
/// #     }
/// # }
/// // Reply is typically created internally by the effect system
/// #[effectful]
/// fn example() -> i32 {
///     let value: i32 = perform!(Test::GetValue); // Creates and uses Reply internally
///     value
/// }
/// let result = example().handle(TestHandler).run();
/// assert_eq!(result, 42);
/// ```
pub struct Reply {
    /// Type-erased storage for the handler's response value
    value: Box<dyn Any + Send>,
}

impl<Op> Effect<Op> {
    /// Creates a new effect with the given operation and no reply.
    ///
    /// This is typically called by the `perform!` macro when an effectful
    /// computation yields an operation to be handled.
    ///
    /// # Arguments
    ///
    /// * `op` - The operation to be performed
    ///
    /// # Returns
    ///
    /// A new `Effect` with the specified operation and no reply value.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let effect = Effect::new(Test::GetValue);
    /// // Effect is now ready to be handled
    /// ```
    pub fn new(op: Op) -> Self {
        Self { op, reply: None }
    }

    /// Stores a pre-boxed reply value in this effect (one-shot only).
    ///
    /// This method is called by handlers to provide the result of processing
    /// the effect operation. The value must already be boxed as `Box<dyn Any + Send>`.
    ///
    /// ## One-Shot Semantics
    ///
    /// Consistent with algae's linear effect model, each effect can be filled with a reply
    /// **exactly once**. Attempting to fill an effect that already has a reply will panic,
    /// ensuring the one-shot invariant is maintained.
    ///
    /// # Arguments
    ///
    /// * `r` - The boxed reply value from the handler
    ///
    /// # Panics
    ///
    /// This method will panic if called on an effect that already has a reply, maintaining
    /// the one-shot (linear) semantics of algae's effect system.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let mut effect = Effect::new(Test::GetValue);
    /// effect.fill_boxed(Box::new(42i32));
    /// // Effect now contains the reply value
    /// ```
    pub fn fill_boxed(&mut self, r: Box<dyn Any + Send>) {
        assert!(self.reply.is_none(), "reply filled twice");
        self.reply = Some(r);
    }

    /// Consumes the effect and extracts the reply value (one-shot consumption).
    ///
    /// This method retrieves the reply that was stored by the handler and
    /// wraps it in a `Reply` for type-safe extraction. The effect is consumed
    /// in the process, enforcing the one-shot semantics of algae's linear effect model.
    ///
    /// ## One-Shot Consumption
    ///
    /// This method takes ownership of the effect (`self`), ensuring that each effect
    /// reply can only be extracted once. This prevents accidental reuse and maintains
    /// the linear control flow guarantees of the effect system.
    ///
    /// # Returns
    ///
    /// A `Reply` containing the handler's response value.
    ///
    /// # Panics
    ///
    /// Panics if the effect has no reply (i.e., if `fill_boxed` was never called).
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let mut effect = Effect::new(Test::GetValue);
    /// effect.fill_boxed(Box::new(42i32));
    /// let reply = effect.get_reply();
    /// let value: i32 = reply.take();
    /// assert_eq!(value, 42);
    /// ```
    pub fn get_reply(self) -> Reply {
        let reply_value = self.reply.expect("Effect has no reply");
        Reply { value: reply_value }
    }
}

impl Reply {
    /// Extracts the contained value with the specified type (one-shot extraction).
    ///
    /// This method performs a runtime type check to ensure the stored value
    /// matches the requested type `R`. If successful, it returns the value.
    /// If the types don't match, it panics with a descriptive error message.
    ///
    /// ## One-Shot Extraction
    ///
    /// This method consumes the `Reply` (takes `self` by value), enforcing algae's
    /// one-shot semantics. Each reply value can only be extracted once, preventing
    /// accidental reuse and maintaining linear control flow.
    ///
    /// # Type Parameters
    ///
    /// * `R` - The expected type of the contained value. Must implement `Any + Send`.
    ///
    /// # Returns
    ///
    /// The contained value of type `R`.
    ///
    /// # Panics
    ///
    /// Panics if the contained value is not of type `R`. The panic message
    /// includes both the expected type name and the actual type ID for debugging.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         Box::new(42i32)
    /// #     }
    /// # }
    /// // Reply is used internally when performing effects
    /// #[effectful]
    /// fn example() -> i32 {
    ///     let value: i32 = perform!(Test::GetValue); // take() called internally
    ///     value
    /// }
    /// let result = example().handle(TestHandler).run();
    /// assert_eq!(result, 42);
    /// ```
    pub fn take<R: Any + Send>(self) -> R {
        match self.value.downcast::<R>() {
            Ok(val) => *val,
            Err(boxed_value) => {
                let expected_name = std::any::type_name::<R>();

                // Try to identify some common types to provide better error messages
                let any_ref = boxed_value.as_ref() as &dyn Any;
                let actual_type = if any_ref.is::<i32>() {
                    "i32"
                } else if any_ref.is::<String>() {
                    "String"
                } else if any_ref.is::<()>() {
                    "()"
                } else if any_ref.is::<bool>() {
                    "bool"
                } else if any_ref.is::<f64>() {
                    "f64"
                } else if any_ref.is::<usize>() {
                    "usize"
                } else if any_ref.is::<Result<String, String>>() {
                    "Result<String, String>"
                } else if any_ref.is::<Result<(), String>>() {
                    "Result<(), String>"
                } else if any_ref.is::<Result<i32, String>>() {
                    "Result<i32, String>"
                } else {
                    "<unknown type>"
                };

                panic!("Type mismatch when taking reply: expected '{expected_name}', but got '{actual_type}'. \
                       This usually means the handler returned the wrong type for this effect operation.");
            }
        }
    }
}

/// Type alias for the complex coroutine type to improve readability.
///
/// This represents a pinned, boxed coroutine that:
/// - Takes `Option<Reply>` as resume argument (the reply from the previous effect)
/// - Returns `R` when the computation completes
/// - Yields `Effect<Op>` when an effect needs to be handled
type EffectCoroutine<R, Op> =
    Pin<Box<dyn Coroutine<Option<Reply>, Return = R, Yield = Effect<Op>> + Send>>;

/// A wrapper around a coroutine that represents an effectful computation.
///
/// `Effectful<R, Op>` encapsulates a computation that may perform effects of type `Op`
/// and eventually produces a result of type `R`. The computation is represented as
/// a coroutine that yields effects to be handled and resumes with the handler's replies.
///
/// This is the core type returned by functions annotated with `#[effectful]`.
/// It provides methods for running the computation with handlers.
///
/// ## Thread Safety
///
/// `Effectful` implements `Send`, allowing effectful computations to be transferred
/// across thread boundaries. This enables concurrent and parallel execution patterns
/// where computations can be spawned on different threads and their results collected.
///
/// # Type Parameters
///
/// * `R` - The return type of the effectful computation
/// * `Op` - The type of effects that can be performed (typically an enum)
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
/// #     }
/// # }
/// #[effectful]
/// fn my_computation() -> i32 {
///     let value: i32 = perform!(Test::GetValue);
///     value * 2
/// }
///
/// let result = my_computation()
///     .handle(TestHandler)
///     .run();
/// assert_eq!(result, 84);
/// ```
pub struct Effectful<R, Op: 'static> {
    /// The underlying coroutine representing the effectful computation
    gen: EffectCoroutine<R, Op>,
}

impl<R, Op: 'static> Effectful<R, Op> {
    /// Creates a new effectful computation from a coroutine.
    ///
    /// This is typically called by the `#[effectful]` macro to wrap the generated
    /// coroutine in an `Effectful` type for easier handling.
    ///
    /// # Type Parameters
    ///
    /// * `G` - The coroutine type that implements the required traits
    ///
    /// # Arguments
    ///
    /// * `g` - The coroutine representing the effectful computation
    ///
    /// # Returns
    ///
    /// A new `Effectful` wrapper around the provided coroutine.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr, stmt_expr_attributes)]
    /// # use algae::prelude::*;
    /// # use std::pin::Pin;
    /// # effect! { Test::GetValue -> i32; }
    /// // This is typically done by the #[effectful] macro
    /// let coroutine = #[coroutine] |_: Option<Reply>| {
    ///     let effect = Effect::new(Test::GetValue);
    ///     let reply = yield effect;
    ///     let value: i32 = reply.unwrap().take();
    ///     value
    /// };
    ///
    /// let effectful = Effectful::new(coroutine);
    /// // Now ready to be run with a handler
    /// ```
    pub fn new<G>(g: G) -> Self
    where
        G: Coroutine<Option<Reply>, Return = R, Yield = Effect<Op>> + 'static + Send,
    {
        Self { gen: Box::pin(g) }
    }

    /// Executes the effectful computation using a single handler.
    ///
    /// This method drives the coroutine to completion by handling each effect
    /// as it's yielded. When an effect is yielded, the handler processes it
    /// and the result is sent back to resume the coroutine.
    ///
    /// # Arguments
    ///
    /// * `h` - The handler that will process all effects
    ///
    /// # Returns
    ///
    /// The final result of the effectful computation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation().run_with(TestHandler);
    /// assert_eq!(result, 42);
    /// ```
    pub fn run_with<H: Handler<Op>>(self, h: H) -> R {
        self.run_unchecked(h)
    }

    /// Private unchecked execution that may panic on unhandled operations.
    fn run_unchecked<H: Handler<Op>>(mut self, mut h: H) -> R {
        // Start with None for the first call
        let mut resume_arg: Option<Reply> = None;

        loop {
            match self.gen.as_mut().resume(resume_arg) {
                CoroutineState::Complete(r) => return r,
                CoroutineState::Yielded(mut eff) => {
                    let reply_any = h.handle(&eff.op);
                    eff.fill_boxed(reply_any);
                    resume_arg = Some(eff.get_reply());
                }
            }
        }
    }

    /// Chains a handler with this effectful computation for fluent syntax.
    ///
    /// This method enables the fluent `.handle(...).run()` pattern by wrapping
    /// the effectful computation and handler in a `Handled` type. The computation
    /// is not executed until `run()` is called on the returned `Handled`.
    ///
    /// This method accepts any type that can act as a handler:
    /// - Types implementing `Handler<Op>` (total handlers)
    /// - Types implementing `PartialHandler<Op>` (partial handlers)
    /// - `VecHandler<Op>` (collections of handlers)
    ///
    /// # Arguments
    ///
    /// * `h` - The handler to use for processing effects
    ///
    /// # Returns
    ///
    /// A `Handled` type that bundles the computation and handler together.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation()
    ///     .handle(TestHandler)
    ///     .run();
    /// assert_eq!(result, 42);
    /// ```
    pub fn handle<H>(self, h: H) -> Handled<R, Op, H> {
        Handled { eff: self, h }
    }

    /// Executes the effectful computation with a partial handler that may decline operations.
    ///
    /// Unlike `run_with`, this method returns a `Result` indicating whether all effects
    /// were successfully handled. If the handler declines to handle an operation (returns `None`),
    /// execution stops and returns `Err(UnhandledOp(op))`.
    ///
    /// # Arguments
    ///
    /// * `h` - A partial handler that may decline to handle some operations
    ///
    /// # Returns
    ///
    /// * `Ok(result)` - If all effects were handled successfully
    /// * `Err(UnhandledOp(op))` - If an effect operation was not handled
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! {
    /// #     Math::Add ((i32, i32)) -> i32;
    /// #     Logger::Info (String) -> ();
    /// # }
    /// struct MathOnlyHandler;
    /// impl PartialHandler<Op> for MathOnlyHandler {
    ///     fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn std::any::Any + Send>> {
    ///         match op {
    ///             Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
    ///             _ => None,
    ///         }
    ///     }
    /// }
    ///
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     let _: () = perform!(Logger::Info("Starting".to_string())); // This will fail
    ///     perform!(Math::Add((2, 3)))
    /// }
    ///
    /// match computation().run_checked(MathOnlyHandler) {
    ///     Ok(result) => println!("Result: {}", result),
    ///     Err(UnhandledOp(op)) => eprintln!("Unhandled: {:?}", op),
    /// }
    /// ```
    pub fn run_checked<H>(mut self, mut h: H) -> Result<R, UnhandledOp<Op>>
    where
        H: PartialHandler<Op>,
    {
        let mut resume_arg = None;
        loop {
            match self.gen.as_mut().resume(resume_arg) {
                CoroutineState::Complete(r) => return Ok(r),
                CoroutineState::Yielded(mut eff) => match h.maybe_handle(&eff.op) {
                    Some(reply_any) => {
                        eff.fill_boxed(reply_any);
                        resume_arg = Some(eff.get_reply());
                    }
                    None => return Err(UnhandledOp(eff.op)),
                },
            }
        }
    }

    /// Executes the effectful computation with a total handler wrapped to support checked execution.
    ///
    /// This is a convenience method for using total handlers with `run_checked`.
    /// Since total handlers always handle all operations, this will only return
    /// `Err` if the handler itself panics.
    ///
    /// # Arguments
    ///
    /// * `h` - A total handler that handles all operations
    ///
    /// # Returns
    ///
    /// * `Ok(result)` - Always, unless the handler panics
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Math::Add ((i32, i32)) -> i32; }
    /// struct MathHandler;
    /// impl Handler<Op> for MathHandler {
    ///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    ///         match op {
    ///             Op::Math(Math::Add((a, b))) => Box::new(a + b),
    ///         }
    ///     }
    /// }
    ///
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Math::Add((2, 3)))
    /// }
    ///
    /// let result = computation().run_checked_with(MathHandler);
    /// assert_eq!(result, Ok(5));
    /// ```
    pub fn run_checked_with<H>(self, h: H) -> Result<R, UnhandledOp<Op>>
    where
        H: Handler<Op>,
    {
        Ok(self.run_with(h))
    }

    /// Attaches multiple handlers at once for processing effects.
    ///
    /// This method creates a `VecHandler` containing all provided handlers and returns
    /// a `Handled` computation ready for execution. Handlers are tried in iteration order
    /// until one accepts each operation.
    ///
    /// # Arguments
    ///
    /// * `iter` - An iterator of handlers to attach
    ///
    /// # Returns
    ///
    /// A `Handled` computation with all handlers attached
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! {
    /// #     Math::Add ((i32, i32)) -> i32;
    /// #     Logger::Info (String) -> ();
    /// #     File::Read (String) -> String;
    /// # }
    /// # struct MathHandler;
    /// # struct LoggerHandler;
    /// # struct FileHandler;
    /// # impl PartialHandler<Op> for MathHandler { /* ... */ }
    /// # impl PartialHandler<Op> for LoggerHandler { /* ... */ }
    /// # impl PartialHandler<Op> for FileHandler { /* ... */ }
    ///
    /// #[effectful]
    /// fn complex_computation() -> String {
    ///     let _: () = perform!(Logger::Info("Starting computation".to_string()));
    ///     let sum: i32 = perform!(Math::Add((5, 3)));
    ///     let content: String = perform!(File::Read("data.txt".to_string()));
    ///     format!("Sum: {}, Content: {}", sum, content)
    /// }
    ///
    /// let result = complex_computation()
    ///     .handle_all([MathHandler, LoggerHandler, FileHandler])
    ///     .run_checked()?;
    /// ```
    pub fn handle_all<I, H>(self, iter: I) -> Handled<R, Op, VecHandler<Op>>
    where
        I: IntoIterator<Item = H>,
        H: PartialHandler<Op> + Send + 'static,
    {
        let mut vec = VecHandler::new();
        for h in iter {
            vec.push(h);
        }
        Handled { eff: self, h: vec }
    }
}

/// A bundled effectful computation and handler ready for execution.
///
/// `Handled` is an intermediate type returned by `Effectful::handle()` that
/// pairs an effectful computation with its handler. It provides a `run()`
/// method to execute the computation. This enables the fluent syntax:
/// `computation().handle(handler).run()`.
///
/// # Type Parameters
///
/// * `R` - The return type of the effectful computation
/// * `Op` - The type of effects that can be performed
/// * `H` - The handler type that processes the effects
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
/// #     }
/// # }
/// #[effectful]
/// fn computation() -> i32 {
///     perform!(Test::GetValue)
/// }
///
/// // .handle() returns a Handled<i32, Op, TestHandler>
/// let handled = computation().handle(TestHandler);
/// let result = handled.run(); // Execute the computation
/// assert_eq!(result, 42);
/// ```
pub struct Handled<R, Op: 'static, H> {
    /// The effectful computation to execute
    eff: Effectful<R, Op>,
    /// The handler that will process effects
    h: H,
}

impl<R, Op: 'static, H: Handler<Op>> Handled<R, Op, H> {
    /// Executes the bundled effectful computation with its handler.
    ///
    /// This is a convenience method that calls `run_with` on the effectful
    /// computation using the bundled handler. This method may panic if
    /// an operation is not handled.
    ///
    /// For a panic-free alternative, use `run_checked()` instead.
    ///
    /// # Returns
    ///
    /// The final result of the effectful computation.
    ///
    /// # Panics
    ///
    /// Panics if the handler does not handle an operation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation()
    ///     .handle(TestHandler)
    ///     .run(); // This calls run()
    /// assert_eq!(result, 42);
    /// ```
    pub fn run(self) -> R {
        self.eff.run_with(self.h)
    }
}

impl<R, Op: 'static, H> Handled<R, Op, H>
where
    H: PartialHandler<Op>,
{
    /// Executes the computation with the partial handler(s).
    ///
    /// Unlike `run()`, this method returns a `Result` that indicates whether
    /// all effects were successfully handled.
    ///
    /// # Returns
    ///
    /// * `Ok(result)` - If all effects were handled
    /// * `Err(UnhandledOp(op))` - If an effect was not handled
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! {
    /// #     Math::Add ((i32, i32)) -> i32;
    /// #     Logger::Info (String) -> ();
    /// # }
    /// # struct MathHandler;
    /// # struct LoggerHandler;
    /// # impl PartialHandler<Op> for MathHandler { /* ... */ }
    /// # impl PartialHandler<Op> for LoggerHandler { /* ... */ }
    ///
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     let _: () = perform!(Logger::Info("Computing...".to_string()));
    ///     perform!(Math::Add((2, 3)))
    /// }
    ///
    /// match computation()
    ///     .handle_all([MathHandler, LoggerHandler])
    ///     .run_checked() {
    ///     Ok(result) => println!("Result: {}", result),
    ///     Err(UnhandledOp(op)) => eprintln!("Unhandled: {:?}", op),
    /// }
    /// ```
    pub fn run_checked(self) -> Result<R, UnhandledOp<Op>> {
        self.eff.run_checked(self.h)
    }
}

/// Trait that all effect handlers must implement.
///
/// A handler defines how to process effect operations. When an effectful
/// computation yields an effect, the handler's `handle` method is called
/// with the operation, and it must return the appropriate response value.
///
/// The response is returned as `Box<dyn Any + Send>` to allow handlers to
/// return different types for different operations. Type safety is ensured
/// by the effect system - the `perform!` macro will extract the correct type.
///
/// # Type Parameters
///
/// * `Op` - The type of operations this handler can process
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! {
/// #     File::Read (String) -> String;
/// #     File::Write ((String, String)) -> ();
/// # }
/// use std::collections::HashMap;
///
/// struct FileHandler {
///     files: HashMap<String, String>,
/// }
///
/// impl Handler<Op> for FileHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::File(File::Read(filename)) => {
///                 let content = self.files.get(filename)
///                     .cloned()
///                     .unwrap_or_else(|| "".to_string());
///                 Box::new(content)
///             }
///             Op::File(File::Write((filename, content))) => {
///                 self.files.insert(filename.clone(), content.clone());
///                 Box::new(())
///             }
///         }
///     }
/// }
/// ```
///
/// # Thread Safety
///
/// The returned `Box<dyn Any + Send>` must be `Send` to allow handlers to
/// work across thread boundaries. This means the values you return must
/// implement `Send`.
///
/// # Type Safety
///
/// Although this method returns a type-erased value, type safety is maintained
/// by the effect system. The effect definitions specify what type each operation
/// should return, and the `perform!` macro will extract that specific type.
/// If there's a mismatch, the program will panic with a descriptive error.
pub trait Handler<Op> {
    /// Processes an effect operation and returns the result.
    ///
    /// This method is called by the effect runtime when an effectful computation
    /// yields an operation that needs to be handled. The handler examines the
    /// operation and returns an appropriate response value.
    ///
    /// # Arguments
    ///
    /// * `op` - The operation to be processed
    ///
    /// # Returns
    ///
    /// The result of processing the operation, boxed as `Box<dyn Any + Send>`.
    /// The type of the returned value should match what the effect definition
    /// specifies for this operation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Math::Add ((i32, i32)) -> i32; }
    /// struct MathHandler;
    ///
    /// impl Handler<Op> for MathHandler {
    ///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    ///         match op {
    ///             Op::Math(Math::Add((a, b))) => {
    ///                 Box::new(a + b) // Returns i32 as specified
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    fn handle(&mut self, op: &Op) -> Box<dyn Any + Send>;
}

/// Trait for handlers that can selectively handle operations.
///
/// A partial handler can choose to process an operation or decline it by returning `None`.
/// This enables composing multiple handlers where each handles a subset of operations.
///
/// # Type Parameters
///
/// * `Op` - The type of operations this handler might process
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! {
/// #     Math::Add ((i32, i32)) -> i32;
/// #     Logger::Info (String) -> ();
/// # }
/// struct MathOnlyHandler;
///
/// impl PartialHandler<Op> for MathOnlyHandler {
///     fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn std::any::Any + Send>> {
///         match op {
///             Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
///             _ => None, // Decline to handle non-math operations
///         }
///     }
/// }
/// ```
pub trait PartialHandler<Op> {
    /// Attempts to process an operation, returning `Some` if handled or `None` if declined.
    ///
    /// # Arguments
    ///
    /// * `op` - The operation to potentially process
    ///
    /// # Returns
    ///
    /// * `Some(result)` - If this handler processed the operation
    /// * `None` - If this handler declines to handle this operation
    fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>>;
}

/// Implementation of PartialHandler for `Box<dyn PartialHandler>`
impl<Op> PartialHandler<Op> for Box<dyn PartialHandler<Op> + Send> {
    fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
        (**self).maybe_handle(op)
    }
}

/// A dynamic collection of partial handlers that attempts each in order.
///
/// `VecHandler` allows composing multiple partial handlers at runtime. When handling
/// an operation, it tries each handler in insertion order until one accepts the operation.
///
/// # Type Parameters
///
/// * `Op` - The type of operations these handlers process
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// let mut vec_handler = VecHandler::<Op>::new();
/// vec_handler.push(MathHandler);
/// vec_handler.push(LoggerHandler);
/// vec_handler.push(FileHandler);
/// ```
pub struct VecHandler<Op> {
    inner: Vec<Box<dyn PartialHandler<Op> + Send>>,
}

impl<Op> VecHandler<Op> {
    /// Creates a new empty handler collection.
    pub fn new() -> Self {
        Self { inner: Vec::new() }
    }

    /// Adds a handler to the collection.
    ///
    /// Handlers are tried in the order they were added.
    ///
    /// # Arguments
    ///
    /// * `h` - The handler to add
    pub fn push<H>(&mut self, h: H)
    where
        H: PartialHandler<Op> + Send + 'static,
    {
        self.inner.push(Box::new(h));
    }
}

impl<Op> Default for VecHandler<Op> {
    fn default() -> Self {
        Self::new()
    }
}

impl<Op> PartialHandler<Op> for VecHandler<Op> {
    fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
        for h in &mut self.inner {
            if let Some(v) = h.maybe_handle(op) {
                return Some(v);
            }
        }
        None
    }
}

/// Handler implementation for VecHandler that returns Result instead of panicking
impl<Op> Handler<Op> for VecHandler<Op>
where
    Op: std::fmt::Debug + 'static,
{
    fn handle(&mut self, op: &Op) -> Box<dyn Any + Send> {
        match self.maybe_handle(op) {
            Some(v) => v,
            None => {
                // For Handler trait, we must return something or panic
                // This preserves backward compatibility
                panic!("Unhandled operation: {op:?}")
            }
        }
    }
}

/// Error type returned when an effect operation has no handler.
///
/// This error contains the unhandled operation, allowing the caller to inspect
/// what went wrong and potentially recover.
///
/// # Type Parameters
///
/// * `Op` - The type of the unhandled operation
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// match computation.run_checked(handler) {
///     Ok(result) => println!("Success: {}", result),
///     Err(UnhandledOp(op)) => eprintln!("Unhandled operation: {:?}", op),
/// }
/// ```
#[derive(Debug, PartialEq)]
pub struct UnhandledOp<Op>(pub Op);

/// Error type returned when an effect operation has no handler (operation name only).
///
/// This lighter-weight error type contains only the operation's type name as a string,
/// useful when you don't need the full operation data.
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// match computation.run_checked(handler) {
///     Ok(result) => println!("Success: {}", result),
///     Err(err) => eprintln!("Unhandled operation: {}", err.op_name),
/// }
/// ```
#[derive(Debug, PartialEq, Clone)]
pub struct UnhandledOpError {
    /// The name of the unhandled operation type
    pub op_name: &'static str,
}

impl<Op: std::fmt::Debug> From<UnhandledOp<Op>> for UnhandledOpError {
    fn from(unhandled: UnhandledOp<Op>) -> Self {
        // Get the debug representation and extract the type name
        let _debug_str = format!("{:?}", unhandled.0);
        // This is a simple heuristic - in practice you might want something more sophisticated
        UnhandledOpError {
            op_name: "UnknownOp", // We'll use a static string for simplicity
        }
    }
}

/// Trait to enable conversion from Handler to PartialHandler
pub trait IntoPartialHandler<Op> {
    /// The resulting partial handler type
    type Output: PartialHandler<Op> + Send + 'static;

    /// Convert to a partial handler
    fn into_partial_handler(self) -> Self::Output;
}

// Implementation for types that already implement PartialHandler
impl<Op, H> IntoPartialHandler<Op> for H
where
    H: PartialHandler<Op> + Send + 'static,
{
    type Output = H;

    fn into_partial_handler(self) -> Self::Output {
        self
    }
}

/// Wrapper to make Handler trait implement PartialHandler  
pub struct HandlerWrapper<Op, H> {
    handler: H,
    _phantom: std::marker::PhantomData<Op>,
}

impl<Op, H> HandlerWrapper<Op, H> {
    pub fn new(handler: H) -> Self {
        Self {
            handler,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<Op, H> PartialHandler<Op> for HandlerWrapper<Op, H>
where
    H: Handler<Op>,
{
    fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
        Some(self.handler.handle(op))
    }
}

// Special case for VecHandler to enable efficient chaining
impl<R, Op: 'static + Send> Handled<R, Op, VecHandler<Op>> {
    /// Adds another handler to an existing VecHandler chain.
    ///
    /// This specialized implementation efficiently adds to an existing VecHandler
    /// without creating a new one.
    pub fn handle<H2>(mut self, h2: H2) -> Handled<R, Op, VecHandler<Op>>
    where
        H2: PartialHandler<Op> + Send + 'static,
    {
        self.h.push(h2);
        self
    }

    /// Adds a total handler to an existing VecHandler chain.
    ///
    /// This method wraps a Handler type to work with the partial handler system.
    pub fn handle_total<H2>(mut self, h2: H2) -> Handled<R, Op, VecHandler<Op>>
    where
        H2: Handler<Op> + Send + 'static,
    {
        self.h.push(HandlerWrapper::new(h2));
        self
    }
}

/// Convenience module that re-exports everything needed to use algae.
///
/// This module provides a single import point for all the essential types
/// and macros needed to work with algebraic effects. Users can simply
/// `use algae::prelude::*` to get started.
///
/// # Re-exported Items
///
/// ## Core Types
/// - [`Effect`] - Represents an effect operation with space for a reply
/// - [`Effectful`] - Wrapper around effectful computations  
/// - [`Handler`] - Trait for implementing effect handlers
/// - [`Reply`] - Container for handler response values
/// - [`PartialHandler`] - Trait for handlers that may decline operations
/// - [`VecHandler`] - Collection of handlers tried in order
/// - [`UnhandledOp`] - Error returned when no handler handles an operation
/// - [`UnhandledOpError`] - Lightweight error with just operation name
/// - [`IntoVecHandler`] - Trait for converting handlers to VecHandler
///
/// ## Macros (when "macros" feature is enabled)
/// - `effect!` - Macro for defining effect families and operations
/// - `effectful` - Attribute macro for marking functions as effectful
/// - `perform!` - Macro for performing effects within effectful functions
///
/// # Examples
///
/// ## With macros (default):
/// ```rust,ignore
/// #![feature(coroutines, coroutine_trait, yield_expr)]
/// use algae::prelude::*;
///
/// // Define effects
/// effect! {
///     Counter::Get -> i32;
///     Counter::Set (i32) -> ();
/// }
///
/// // Create effectful functions
/// #[effectful]
/// fn increment() -> i32 {
///     let current: i32 = perform!(Counter::Get);
///     let _: () = perform!(Counter::Set(current + 1));
///     current + 1
/// }
///
/// // Implement handlers
/// struct CounterHandler { value: i32 }
///
/// impl Handler<Op> for CounterHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::Counter(Counter::Get) => Box::new(self.value),
///             Op::Counter(Counter::Set(new_val)) => {
///                 self.value = *new_val;
///                 Box::new(())
///             }
///         }
///     }
/// }
///
/// // Run computations
/// let result = increment()
///     .handle(CounterHandler { value: 5 })
///     .run();
/// assert_eq!(result, 6);
/// ```
///
/// ## Without macros (manual approach):
/// When using algae without the "macros" feature, you need to define
/// your effect types and handlers manually using the core types.
pub mod prelude {
    pub use crate::{
        Effect, Effectful, Handler, HandlerWrapper, IntoPartialHandler, PartialHandler, Reply,
        UnhandledOp, UnhandledOpError, VecHandler,
    };

    #[cfg(feature = "macros")]
    pub use algae_macros::{effect, effectful, perform};
}

/// Helper macro for combining multiple root enums into one unified enum.
///
/// This macro allows you to merge effect operations from different modules
/// that use custom root enum names into a single root enum for easier handling.
///
/// # Syntax
///
/// ```ignore
/// combine_roots!(pub Op = module_a::ConsoleOp, module_b::FileOp, module_c::NetOp);
/// ```
///
/// This generates:
/// - A new enum with the specified name containing all the other enums as variants
/// - `From` implementations to convert each source enum to the combined enum
///
/// # Example
///
/// ```ignore
/// mod console {
///     use algae::prelude::*;
///     effect! {
///         root ConsoleOp;
///         Console::Print (String) -> ();
///         Console::ReadLine -> String;
///     }
/// }
///
/// mod file {
///     use algae::prelude::*;
///     effect! {
///         root FileOp;
///         File::Read (String) -> String;
///         File::Write ((String, String)) -> ();
///     }
/// }
///
/// // Combine them into a unified root enum
/// combine_roots!(pub Op = console::ConsoleOp, file::FileOp);
///
/// // Now you can write handlers for the unified Op enum
/// struct UnifiedHandler;
/// impl Handler<Op> for UnifiedHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::ConsoleOp(console_op) => {
///                 // Handle console operations
///             }
///             Op::FileOp(file_op) => {
///                 // Handle file operations  
///             }
///         }
///     }
/// }
/// ```
#[macro_export]
macro_rules! combine_roots {
    ( $vis:vis $root:ident = $( $path:ident ),+ $(,)? ) => {
        #[derive(Debug)]
        $vis enum $root {
            $( $path($path) ),+
        }

        $(
            impl From<$path> for $root {
                fn from(f: $path) -> Self {
                    $root::$path(f)
                }
            }
        )+

        // Note: Default implementation is not automatically generated
        // Users should implement Default manually if needed, as it's unclear
        // which variant should be the default when combining multiple enums
    };
}

#[cfg(all(test, feature = "macros"))]
mod tests {
    use crate as algae;
    use algae::prelude::*;
    use std::any::Any;
    use std::collections::HashMap;

    // Define test effects for comprehensive testing
    effect! {
        Test::GetValue -> i32;
        Test::SetValue (i32) -> ();

        Math::Add ((i32, i32)) -> i32;
        Math::Multiply ((i32, i32)) -> i32;
        Math::Divide ((i32, i32)) -> Result<i32, String>;

        IO::ReadString -> String;
        IO::WriteString (String) -> ();
        IO::ReadNumber -> i32;

        Logger::Info (String) -> ();
        Logger::Error (String) -> ();
        Logger::GetLogCount -> usize;
    }

    // Basic state handler for simple tests
    struct TestHandler {
        value: i32,
    }

    impl TestHandler {
        fn new(initial: i32) -> Self {
            Self { value: initial }
        }
    }

    impl Handler<Op> for TestHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Test(Test::GetValue) => Box::new(self.value),
                Op::Test(Test::SetValue(new_val)) => {
                    self.value = *new_val;
                    Box::new(())
                }
                _ => panic!("TestHandler cannot handle this operation: {op:?}"),
            }
        }
    }

    // Math operations handler
    struct MathHandler;

    impl Handler<Op> for MathHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Math(Math::Add((a, b))) => Box::new(a + b),
                Op::Math(Math::Multiply((a, b))) => Box::new(a * b),
                Op::Math(Math::Divide((a, b))) => {
                    if *b == 0 {
                        Box::new(Err::<i32, String>("Division by zero".to_string()))
                    } else {
                        Box::new(Ok::<i32, String>(a / b))
                    }
                }
                _ => panic!("MathHandler cannot handle this operation: {op:?}"),
            }
        }
    }

    // Mock IO handler with predefined responses
    struct MockIOHandler {
        string_responses: Vec<String>,
        number_responses: Vec<i32>,
        string_index: usize,
        number_index: usize,
        written_strings: Vec<String>,
    }

    impl MockIOHandler {
        fn new(string_responses: Vec<String>, number_responses: Vec<i32>) -> Self {
            Self {
                string_responses,
                number_responses,
                string_index: 0,
                number_index: 0,
                written_strings: Vec::new(),
            }
        }

        #[allow(dead_code)]
        fn written_strings(&self) -> &[String] {
            &self.written_strings
        }
    }

    impl Handler<Op> for MockIOHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::IO(IO::ReadString) => {
                    let response = if self.string_index < self.string_responses.len() {
                        self.string_responses[self.string_index].clone()
                    } else {
                        "default".to_string()
                    };
                    self.string_index += 1;
                    Box::new(response)
                }
                Op::IO(IO::WriteString(s)) => {
                    self.written_strings.push(s.clone());
                    Box::new(())
                }
                Op::IO(IO::ReadNumber) => {
                    let response = if self.number_index < self.number_responses.len() {
                        self.number_responses[self.number_index]
                    } else {
                        0
                    };
                    self.number_index += 1;
                    Box::new(response)
                }
                _ => panic!("MockIOHandler cannot handle this operation: {op:?}"),
            }
        }
    }

    // Logging handler that tracks log calls
    struct LoggingHandler {
        logs: Vec<(String, String)>, // (level, message)
    }

    impl LoggingHandler {
        fn new() -> Self {
            Self { logs: Vec::new() }
        }

        #[allow(dead_code)]
        fn get_logs(&self) -> &[(String, String)] {
            &self.logs
        }
    }

    impl Handler<Op> for LoggingHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Logger(Logger::Info(msg)) => {
                    self.logs.push(("INFO".to_string(), msg.clone()));
                    Box::new(())
                }
                Op::Logger(Logger::Error(msg)) => {
                    self.logs.push(("ERROR".to_string(), msg.clone()));
                    Box::new(())
                }
                Op::Logger(Logger::GetLogCount) => Box::new(self.logs.len()),
                _ => panic!("LoggingHandler cannot handle this operation: {op:?}"),
            }
        }
    }

    // Combined handler for multiple effect types
    struct CombinedTestHandler {
        test_handler: TestHandler,
        math_handler: MathHandler,
        io_handler: MockIOHandler,
        logger_handler: LoggingHandler,
    }

    impl CombinedTestHandler {
        fn new(
            initial_value: i32,
            string_responses: Vec<String>,
            number_responses: Vec<i32>,
        ) -> Self {
            Self {
                test_handler: TestHandler::new(initial_value),
                math_handler: MathHandler,
                io_handler: MockIOHandler::new(string_responses, number_responses),
                logger_handler: LoggingHandler::new(),
            }
        }

        #[allow(dead_code)]
        fn get_written_strings(&self) -> &[String] {
            self.io_handler.written_strings()
        }

        #[allow(dead_code)]
        fn get_logs(&self) -> &[(String, String)] {
            self.logger_handler.get_logs()
        }
    }

    impl Handler<Op> for CombinedTestHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Test(_) => self.test_handler.handle(op),
                Op::Math(_) => self.math_handler.handle(op),
                Op::IO(_) => self.io_handler.handle(op),
                Op::Logger(_) => self.logger_handler.handle(op),
            }
        }
    }

    // Test effectful functions
    #[effectful]
    fn test_computation() -> i32 {
        let current: i32 = perform!(Test::GetValue);
        let _: () = perform!(Test::SetValue(current * 2));
        let doubled: i32 = perform!(Test::GetValue);
        doubled + 10
    }

    #[effectful]
    fn math_computation() -> i32 {
        let sum: i32 = perform!(Math::Add((5, 3)));
        let product: i32 = perform!(Math::Multiply((sum, 2)));
        let result: Result<i32, String> = perform!(Math::Divide((product, 4)));
        result.unwrap_or(-1)
    }

    #[effectful]
    fn io_program() -> String {
        let _: () = perform!(IO::WriteString("Enter name:".to_string()));
        let name: String = perform!(IO::ReadString);
        let _: () = perform!(IO::WriteString("Enter age:".to_string()));
        let age: i32 = perform!(IO::ReadNumber);
        format!("{name} is {age} years old")
    }

    #[effectful]
    fn logging_program() -> usize {
        let _: () = perform!(Logger::Info("Starting program".to_string()));
        let _: () = perform!(Logger::Info("Processing data".to_string()));
        let _: () = perform!(Logger::Error("Something went wrong".to_string()));
        let count: usize = perform!(Logger::GetLogCount);
        count
    }

    #[effectful]
    fn complex_program() -> String {
        // Log start
        let _: () = perform!(Logger::Info("Complex program started".to_string()));

        // Get initial state
        let initial: i32 = perform!(Test::GetValue);

        // Do some math
        let doubled: i32 = perform!(Math::Multiply((initial, 2)));
        let _: () = perform!(Test::SetValue(doubled));

        // Read input
        let _: () = perform!(IO::WriteString("Enter multiplier:".to_string()));
        let multiplier: i32 = perform!(IO::ReadNumber);

        // More math
        let result: i32 = perform!(Math::Multiply((doubled, multiplier)));

        // Log result
        let _: () = perform!(Logger::Info(format!("Result calculated: {result}")));

        format!("Final result: {result}")
    }

    #[effectful]
    fn nested_effects() -> i32 {
        fn inner_computation() -> Effectful<i32, Op> {
            inner_effectful()
        }

        #[effectful]
        fn inner_effectful() -> i32 {
            let value: i32 = perform!(Test::GetValue);
            perform!(Math::Add((value, 5)))
        }

        let base: i32 = perform!(Test::GetValue);
        let _: () = perform!(Test::SetValue(base + 1));
        let inner_result: i32 = inner_computation()
            .handle(CombinedTestHandler::new(10, vec![], vec![]))
            .run();
        perform!(Math::Add((base, inner_result)))
    }

    #[effectful]
    fn error_handling_program() -> Result<i32, String> {
        let _: () = perform!(Logger::Info("Testing error handling".to_string()));
        let result: Result<i32, String> = perform!(Math::Divide((10, 0)));
        match result {
            Ok(val) => {
                let _: () = perform!(Logger::Info(format!("Division successful: {val}")));
                Ok(val)
            }
            Err(err) => {
                let _: () = perform!(Logger::Error(format!("Division failed: {err}")));
                Err(err)
            }
        }
    }

    // Basic functionality tests
    #[test]
    fn test_basic_effects() {
        let result = test_computation().handle(TestHandler::new(5)).run();

        assert_eq!(result, 20); // (5 * 2) + 10 = 20
    }

    #[test]
    fn test_different_initial_values() {
        let result = test_computation().handle(TestHandler::new(3)).run();

        assert_eq!(result, 16); // (3 * 2) + 10 = 16
    }

    #[test]
    fn test_math_operations() {
        let result = math_computation().handle(MathHandler).run();

        assert_eq!(result, 4); // (5 + 3) * 2 / 4 = 4
    }

    #[test]
    fn test_io_operations() {
        let result = io_program()
            .handle(MockIOHandler::new(vec!["Alice".to_string()], vec![25]))
            .run();

        assert_eq!(result, "Alice is 25 years old");
    }

    #[test]
    fn test_logging_operations() {
        let handler = LoggingHandler::new();
        let result = logging_program().handle(handler).run();

        assert_eq!(result, 3);
        // Note: handler is moved into the effectful computation, so we can't inspect its logs afterwards
    }

    #[test]
    fn test_combined_handler() {
        let handler = CombinedTestHandler::new(5, vec!["test".to_string()], vec![3]);
        let result = complex_program().handle(handler).run();

        assert_eq!(result, "Final result: 30"); // 5 * 2 * 3 = 30
                                                // Note: handler is moved into the effectful computation
    }

    #[test]
    fn test_error_handling() {
        let handler = CombinedTestHandler::new(0, vec![], vec![]);
        let result = error_handling_program().handle(handler).run();

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero");
        // Note: handler is moved into the effectful computation
    }

    #[test]
    fn test_multiple_handler_calls() {
        let result1 = test_computation().handle(TestHandler::new(1)).run();
        let result2 = test_computation().handle(TestHandler::new(2)).run();
        let result3 = test_computation().handle(TestHandler::new(3)).run();

        assert_eq!(result1, 12); // (1 * 2) + 10 = 12
        assert_eq!(result2, 14); // (2 * 2) + 10 = 14
        assert_eq!(result3, 16); // (3 * 2) + 10 = 16
    }

    #[test]
    fn test_zero_effects() {
        #[effectful]
        fn no_effects() -> i32 {
            42
        }

        let result = no_effects().handle(TestHandler::new(0)).run();

        assert_eq!(result, 42);
    }

    #[test]
    fn test_single_effect() {
        #[effectful]
        fn single_effect() -> i32 {
            perform!(Test::GetValue)
        }

        let result = single_effect().handle(TestHandler::new(99)).run();

        assert_eq!(result, 99);
    }

    #[test]
    fn test_many_effects() {
        #[effectful]
        fn many_effects() -> i32 {
            let mut sum = 0;
            for i in 1..=10 {
                let _: () = perform!(Test::SetValue(i));
                let val: i32 = perform!(Test::GetValue);
                sum += val;
            }
            sum
        }

        let result = many_effects().handle(TestHandler::new(0)).run();

        assert_eq!(result, 55); // 1+2+3+...+10 = 55
    }

    #[test]
    fn test_different_return_types() {
        #[effectful]
        fn return_string() -> String {
            let val: i32 = perform!(Test::GetValue);
            format!("Value is {val}")
        }

        #[effectful]
        fn return_bool() -> bool {
            let val: i32 = perform!(Test::GetValue);
            val > 5
        }

        #[effectful]
        fn return_option() -> Option<i32> {
            let val: i32 = perform!(Test::GetValue);
            if val > 0 {
                Some(val)
            } else {
                None
            }
        }

        let string_result = return_string().handle(TestHandler::new(42)).run();
        assert_eq!(string_result, "Value is 42");

        let bool_result = return_bool().handle(TestHandler::new(10)).run();
        assert!(bool_result);

        let option_result = return_option().handle(TestHandler::new(-1)).run();
        assert_eq!(option_result, None);
    }

    #[test]
    fn test_handler_state_persistence() {
        #[effectful]
        fn increment_twice() -> (i32, i32) {
            let first: i32 = perform!(Test::GetValue);
            let _: () = perform!(Test::SetValue(first + 1));
            let second: i32 = perform!(Test::GetValue);
            let _: () = perform!(Test::SetValue(second + 1));
            let third: i32 = perform!(Test::GetValue);
            (first, third)
        }

        let result = increment_twice().handle(TestHandler::new(10)).run();

        assert_eq!(result, (10, 12));
    }

    // Edge case tests
    #[test]
    fn test_effect_with_unit_return() {
        #[effectful]
        fn unit_return() -> () {
            let _: () = perform!(Test::SetValue(42));
        }

        unit_return().handle(TestHandler::new(0)).run();
    }

    #[test]
    fn test_complex_data_types() {
        effect! {
            Complex::GetVector -> Vec<i32>;
            Complex::GetMap -> HashMap<String, i32>;
        }

        struct ComplexHandler;

        impl Handler<Op> for ComplexHandler {
            fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
                match op {
                    Op::Complex(Complex::GetVector) => Box::new(vec![1, 2, 3, 4, 5]),
                    Op::Complex(Complex::GetMap) => {
                        let mut map = HashMap::new();
                        map.insert("a".to_string(), 1);
                        map.insert("b".to_string(), 2);
                        Box::new(map)
                    }
                }
            }
        }

        #[effectful]
        fn complex_data() -> (Vec<i32>, HashMap<String, i32>) {
            let vec: Vec<i32> = perform!(Complex::GetVector);
            let map: HashMap<String, i32> = perform!(Complex::GetMap);
            (vec, map)
        }

        let (vec, map) = complex_data().handle(ComplexHandler).run();

        assert_eq!(vec, vec![1, 2, 3, 4, 5]);
        assert_eq!(map.get("a"), Some(&1));
        assert_eq!(map.get("b"), Some(&2));
    }

    // ============================================================================
    // Custom Root Enum Tests
    // ============================================================================

    mod custom_root_tests {
        use super::*;

        // Test effect with custom root name
        effect! {
            root CustomOp;
            Custom::GetValue -> i32;
            Custom::SetValue (i32) -> ();
        }

        // Another effect with different custom root name
        effect! {
            root AnotherOp;
            Another::GetString -> String;
            Another::SetString (String) -> ();
        }

        struct CustomHandler {
            value: i32,
        }

        impl Handler<CustomOp> for CustomHandler {
            fn handle(&mut self, op: &CustomOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    CustomOp::Custom(Custom::GetValue) => Box::new(self.value),
                    CustomOp::Custom(Custom::SetValue(val)) => {
                        self.value = *val;
                        Box::new(())
                    }
                }
            }
        }

        struct AnotherHandler {
            text: String,
        }

        impl Handler<AnotherOp> for AnotherHandler {
            fn handle(&mut self, op: &AnotherOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    AnotherOp::Another(Another::GetString) => Box::new(self.text.clone()),
                    AnotherOp::Another(Another::SetString(text)) => {
                        self.text = text.clone();
                        Box::new(())
                    }
                }
            }
        }

        #[test]
        fn test_custom_root_basic() {
            fn test_computation() -> algae::Effectful<i32, CustomOp> {
                algae::Effectful::new(
                    #[coroutine]
                    move |mut _reply: Option<algae::Reply>| {
                        // Get current value
                        let current: i32 = {
                            let effect = algae::Effect::new(Custom::GetValue.into());
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<i32>()
                        };

                        // Set new value
                        {
                            let effect = algae::Effect::new(Custom::SetValue(current + 10).into());
                            let reply_opt = yield effect;
                            let _: () = reply_opt.unwrap().take::<()>();
                        }

                        // Get updated value
                        let updated: i32 = {
                            let effect = algae::Effect::new(Custom::GetValue.into());
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<i32>()
                        };

                        updated
                    },
                )
            }

            let result = test_computation().handle(CustomHandler { value: 5 }).run();

            assert_eq!(result, 15);
        }

        #[test]
        fn test_another_custom_root() {
            fn string_computation() -> algae::Effectful<String, AnotherOp> {
                algae::Effectful::new(
                    #[coroutine]
                    move |mut _reply: Option<algae::Reply>| {
                        // Get current string
                        let current: String = {
                            let effect = algae::Effect::new(Another::GetString.into());
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<String>()
                        };

                        // Set new string
                        {
                            let effect = algae::Effect::new(
                                Another::SetString(format!("{current} world!")).into(),
                            );
                            let reply_opt = yield effect;
                            let _: () = reply_opt.unwrap().take::<()>();
                        }

                        // Get updated string
                        let updated: String = {
                            let effect = algae::Effect::new(Another::GetString.into());
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<String>()
                        };

                        updated
                    },
                )
            }

            let result = string_computation()
                .handle(AnotherHandler {
                    text: "Hello".to_string(),
                })
                .run();

            assert_eq!(result, "Hello world!");
        }

        // Test the combine_roots! macro
        algae::combine_roots!(CombinedOp = CustomOp, AnotherOp);

        struct CombinedHandler {
            custom: CustomHandler,
            another: AnotherHandler,
        }

        impl Handler<CombinedOp> for CombinedHandler {
            fn handle(&mut self, op: &CombinedOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    CombinedOp::CustomOp(custom_op) => self.custom.handle(custom_op),
                    CombinedOp::AnotherOp(another_op) => self.another.handle(another_op),
                }
            }
        }

        #[test]
        fn test_combine_roots() {
            fn combined_computation() -> algae::Effectful<String, CombinedOp> {
                algae::Effectful::new(
                    #[coroutine]
                    move |mut _reply: Option<algae::Reply>| {
                        // Use custom effect
                        let value: i32 = {
                            let effect =
                                algae::Effect::new(CombinedOp::CustomOp(Custom::GetValue.into()));
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<i32>()
                        };

                        // Use another effect
                        let text: String = {
                            let effect = algae::Effect::new(CombinedOp::AnotherOp(
                                Another::GetString.into(),
                            ));
                            let reply_opt = yield effect;
                            reply_opt.unwrap().take::<String>()
                        };

                        format!("{text}: {value}")
                    },
                )
            }

            let result = combined_computation()
                .handle(CombinedHandler {
                    custom: CustomHandler { value: 42 },
                    another: AnotherHandler {
                        text: "Test".to_string(),
                    },
                })
                .run();

            assert_eq!(result, "Test: 42");
        }
    }

    // ============================================================================
    // One-Shot Guarantee Tests
    // ============================================================================

    #[test]
    fn test_one_shot_effect_fill() {
        // Test that filling an effect twice panics (enforcing one-shot guarantee)
        let mut effect = Effect::new(Test::GetValue);

        // First fill should succeed
        effect.fill_boxed(Box::new(42i32));

        // Second fill should panic
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            effect.fill_boxed(Box::new(24i32));
        }));

        assert!(result.is_err(), "Expected panic when filling effect twice");

        // The panic message should contain our assertion text
        if let Err(panic_payload) = result {
            if let Some(panic_str) = panic_payload.downcast_ref::<&str>() {
                assert!(
                    panic_str.contains("reply filled twice"),
                    "Panic message should mention 'reply filled twice', got: {panic_str}"
                );
            } else if let Some(panic_string) = panic_payload.downcast_ref::<String>() {
                assert!(
                    panic_string.contains("reply filled twice"),
                    "Panic message should mention 'reply filled twice', got: {panic_string}"
                );
            }
        }
    }

    #[test]
    fn test_one_shot_effect_get_reply_without_fill() {
        // Test that get_reply panics when no reply has been filled
        let effect = Effect::new(Test::GetValue);

        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _ = effect.get_reply();
        }));

        assert!(
            result.is_err(),
            "Expected panic when calling get_reply on unfilled effect"
        );
    }

    #[test]
    fn test_one_shot_reply_take_wrong_type() {
        // Test that Reply::take panics with wrong type (additional safety check)
        let mut effect = Effect::new(Test::GetValue);
        effect.fill_boxed(Box::new(42i32));

        let reply = effect.get_reply();

        // Try to take with wrong type should panic
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: String = reply.take();
        }));

        assert!(
            result.is_err(),
            "Expected panic when taking reply with wrong type"
        );

        // Check that the panic message contains helpful type information
        if let Err(panic_payload) = result {
            let panic_message = if let Some(panic_str) = panic_payload.downcast_ref::<&str>() {
                panic_str.to_string()
            } else if let Some(panic_string) = panic_payload.downcast_ref::<String>() {
                panic_string.clone()
            } else {
                "Unknown panic message".to_string()
            };

            // Should mention both expected and actual types
            assert!(
                panic_message.contains("expected 'alloc::string::String'")
                    || panic_message.contains("expected 'String'"),
                "Panic message should mention expected type String, got: {panic_message}"
            );
            assert!(
                panic_message.contains("but got 'i32'"),
                "Panic message should mention actual type i32, got: {panic_message}"
            );
        }
    }

    #[test]
    fn test_reply_take_type_mismatch_common_types() {
        // Test error messages for various common type mismatches

        // Test i32 -> String mismatch
        let mut effect1 = Effect::new(Test::GetValue);
        effect1.fill_boxed(Box::new(42i32));
        let reply1 = effect1.get_reply();

        let result1 = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: String = reply1.take();
        }));
        assert!(result1.is_err());

        // Test String -> i32 mismatch
        let mut effect2 = Effect::new(Test::GetValue);
        effect2.fill_boxed(Box::new("hello".to_string()));
        let reply2 = effect2.get_reply();

        let result2 = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: i32 = reply2.take();
        }));
        assert!(result2.is_err());

        // Test () -> bool mismatch
        let mut effect3 = Effect::new(Test::GetValue);
        effect3.fill_boxed(Box::new(()));
        let reply3 = effect3.get_reply();

        let result3 = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: bool = reply3.take();
        }));
        assert!(result3.is_err());
    }

    #[test]
    fn test_reply_take_result_type_mismatch() {
        // Test error messages for Result type mismatches (common in algae)
        let mut effect = Effect::new(Test::GetValue);
        effect.fill_boxed(Box::new(Ok::<String, String>("success".to_string())));
        let reply = effect.get_reply();

        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: Result<i32, String> = reply.take();
        }));

        assert!(
            result.is_err(),
            "Expected panic when taking Result with wrong type"
        );

        // Check that the panic message mentions Result types
        if let Err(panic_payload) = result {
            let panic_message = if let Some(panic_str) = panic_payload.downcast_ref::<&str>() {
                panic_str.to_string()
            } else if let Some(panic_string) = panic_payload.downcast_ref::<String>() {
                panic_string.clone()
            } else {
                "Unknown panic message".to_string()
            };

            // Should mention Result types
            assert!(
                panic_message.contains("Result") && panic_message.contains("String"),
                "Panic message should mention Result types, got: {panic_message}"
            );
        }
    }

    #[test]
    fn test_one_shot_fill_and_get_success() {
        // Test the happy path: fill once, get once - should work perfectly
        let mut effect = Effect::new(Test::GetValue);

        // Fill with a value
        effect.fill_boxed(Box::new(42i32));

        // Get reply and extract value
        let reply = effect.get_reply();
        let value: i32 = reply.take();

        assert_eq!(value, 42);
    }

    // ============================================================================
    // Partial Handler Tests
    // ============================================================================

    #[test]
    fn test_partial_handler_basic() {
        // Test basic partial handler functionality
        struct MathOnlyHandler;

        impl PartialHandler<Op> for MathOnlyHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    Op::Math(Math::Multiply((a, b))) => Some(Box::new(a * b)),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn math_only() -> i32 {
            let sum: i32 = perform!(Math::Add((5, 3)));
            let product: i32 = perform!(Math::Multiply((sum, 2)));
            product
        }

        let result = math_only().run_checked(MathOnlyHandler);
        assert_eq!(result, Ok(16)); // (5 + 3) * 2 = 16
    }

    #[test]
    fn test_partial_handler_decline() {
        // Test that partial handlers correctly decline operations
        struct MathOnlyHandler;

        impl PartialHandler<Op> for MathOnlyHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(_) => Some(Box::new(42i32)), // Dummy response
                    _ => None,
                }
            }
        }

        #[effectful]
        fn mixed_effects() -> i32 {
            let _: () = perform!(Logger::Info("Starting".to_string())); // This should fail
            perform!(Math::Add((1, 2)))
        }

        let result = mixed_effects().run_checked(MathOnlyHandler);
        assert!(result.is_err());

        if let Err(UnhandledOp(op)) = result {
            match op {
                Op::Logger(Logger::Info(_)) => (), // Expected
                _ => panic!("Wrong unhandled operation"),
            }
        }
    }

    #[test]
    fn test_vec_handler() {
        // Test VecHandler with multiple partial handlers
        struct MathPartialHandler;
        struct LoggerPartialHandler {
            logs: Vec<String>,
        }

        impl PartialHandler<Op> for MathPartialHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for LoggerPartialHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(msg)) => {
                        self.logs.push(msg.clone());
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        #[effectful]
        fn combined_effects() -> i32 {
            let _: () = perform!(Logger::Info("Computing sum".to_string()));
            let sum: i32 = perform!(Math::Add((10, 20)));
            let _: () = perform!(Logger::Info(format!("Result: {}", sum)));
            sum
        }

        let mut vec_handler = VecHandler::new();
        vec_handler.push(MathPartialHandler);
        vec_handler.push(LoggerPartialHandler { logs: Vec::new() });

        let result = combined_effects().run_checked(vec_handler);
        assert_eq!(result, Ok(30));
    }

    #[test]
    fn test_handle_all() {
        // Test handle_all with array of handlers
        struct AddHandler;
        struct MultiplyHandler;
        struct InfoHandler;

        impl PartialHandler<Op> for AddHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for MultiplyHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Multiply((a, b))) => Some(Box::new(a * b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for InfoHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(_)) => Some(Box::new(())),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn multi_effect_computation() -> i32 {
            let _: () = perform!(Logger::Info("Starting".to_string()));
            let sum: i32 = perform!(Math::Add((7, 3)));
            let result: i32 = perform!(Math::Multiply((sum, 4)));
            let _: () = perform!(Logger::Info("Done".to_string()));
            result
        }

        // Test with manual VecHandler
        let mut vec_handler = VecHandler::new();
        vec_handler.push(AddHandler);
        vec_handler.push(MultiplyHandler);
        vec_handler.push(InfoHandler);

        let result = multi_effect_computation().run_checked(vec_handler);

        assert_eq!(result, Ok(40)); // (7 + 3) * 4 = 40
    }

    #[test]
    fn test_handle_all_method() {
        // Test the actual handle_all method
        struct MathHandler;
        struct LogHandler;

        impl PartialHandler<Op> for MathHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for LogHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(_)) => Some(Box::new(())),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn computation() -> i32 {
            let _: () = perform!(Logger::Info("Computing".to_string()));
            perform!(Math::Add((15, 25)))
        }

        // Using handle_all with a vec
        let handlers: Vec<Box<dyn PartialHandler<Op> + Send>> =
            vec![Box::new(MathHandler), Box::new(LogHandler)];

        let result = computation().handle_all(handlers).run_checked();

        assert_eq!(result, Ok(40));
    }

    #[test]
    fn test_handle_all_with_vec() {
        // Test handle_all with Vec
        struct StdoutHandler;
        struct CalculatorHandler;

        impl PartialHandler<Op> for StdoutHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::IO(IO::WriteString(s)) => {
                        // In tests, just acknowledge without printing
                        let _ = s;
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for CalculatorHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn program() -> i32 {
            let _: () = perform!(IO::WriteString("2 + 3 =".to_string()));
            perform!(Math::Add((2, 3)))
        }

        let mut vec_handler = VecHandler::new();
        vec_handler.push(StdoutHandler);
        vec_handler.push(CalculatorHandler);

        let result = program().run_checked(vec_handler);

        assert_eq!(result, Ok(5));
    }

    #[test]
    fn test_handler_chain() {
        // Test chaining handlers with .handle()
        struct FirstHandler;
        struct SecondHandler;
        struct ThirdHandler;

        impl PartialHandler<Op> for FirstHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for SecondHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(_)) => Some(Box::new(())),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for ThirdHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Multiply((a, b))) => Some(Box::new(a * b)),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn chained_computation() -> i32 {
            let _: () = perform!(Logger::Info("Start".to_string()));
            let x: i32 = perform!(Math::Add((5, 5)));
            let y: i32 = perform!(Math::Multiply((x, 3)));
            let _: () = perform!(Logger::Info("End".to_string()));
            y
        }

        let mut vec_handler = VecHandler::new();
        vec_handler.push(FirstHandler);
        vec_handler.push(SecondHandler);
        vec_handler.push(ThirdHandler);

        let result = chained_computation().run_checked(vec_handler);

        assert_eq!(result, Ok(30)); // (5 + 5) * 3 = 30
    }

    #[test]
    fn test_unhandled_op_error() {
        // Test that UnhandledOp contains the correct operation
        struct EmptyHandler;

        impl PartialHandler<Op> for EmptyHandler {
            fn maybe_handle(&mut self, _op: &Op) -> Option<Box<dyn Any + Send>> {
                None // Decline everything
            }
        }

        #[effectful]
        fn failing_computation() -> i32 {
            perform!(Math::Add((1, 2)))
        }

        let result = failing_computation().run_checked(EmptyHandler);
        assert!(result.is_err());

        if let Err(UnhandledOp(op)) = result {
            match op {
                Op::Math(Math::Add((1, 2))) => (), // Expected
                _ => panic!("Wrong unhandled operation"),
            }
        }
    }

    #[test]
    fn test_total_handler_as_partial() {
        // Test that total handlers work with run_checked_with
        struct TotalMathHandler;

        impl Handler<Op> for TotalMathHandler {
            fn handle(&mut self, op: &Op) -> Box<dyn Any + Send> {
                match op {
                    Op::Math(Math::Add((a, b))) => Box::new(a + b),
                    Op::Math(Math::Multiply((a, b))) => Box::new(a * b),
                    _ => panic!("TotalMathHandler cannot handle {op:?}"),
                }
            }
        }

        #[effectful]
        fn math_computation() -> i32 {
            let x: i32 = perform!(Math::Add((4, 6)));
            perform!(Math::Multiply((x, 2)))
        }

        // Total handler used with run_checked_with
        let result = math_computation().run_checked_with(TotalMathHandler);
        assert_eq!(result, Ok(20)); // (4 + 6) * 2 = 20
    }

    #[test]
    fn test_mixed_handler_types() {
        // Test mixing different partial handlers
        struct PartialMathHandler;
        struct PartialLogHandler;

        impl PartialHandler<Op> for PartialMathHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for PartialLogHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(_)) => Some(Box::new(())),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn mixed_computation() -> i32 {
            let _: () = perform!(Logger::Info("Starting".to_string()));
            perform!(Math::Add((8, 12)))
        }

        let mut vec_handler = VecHandler::new();
        vec_handler.push(PartialMathHandler);
        vec_handler.push(PartialLogHandler);

        let result = mixed_computation().run_checked(vec_handler);

        assert_eq!(result, Ok(20));
    }

    #[test]
    fn test_handler_ordering() {
        // Test that handlers are tried in order
        struct FirstCatchAllHandler;
        struct SecondHandler;

        impl PartialHandler<Op> for FirstCatchAllHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((_, _))) => Some(Box::new(100i32)), // Always return 100
                    _ => None,
                }
            }
        }

        impl PartialHandler<Op> for SecondHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)), // Correct addition
                    _ => None,
                }
            }
        }

        #[effectful]
        fn order_test() -> i32 {
            perform!(Math::Add((5, 7)))
        }

        // First handler should catch it
        let mut vec_handler1 = VecHandler::new();
        vec_handler1.push(FirstCatchAllHandler);
        vec_handler1.push(SecondHandler);

        let result1 = order_test().run_checked(vec_handler1);
        assert_eq!(result1, Ok(100));

        // Reverse order - second handler (now first) should give correct result
        let mut vec_handler2 = VecHandler::new();
        vec_handler2.push(SecondHandler);
        vec_handler2.push(FirstCatchAllHandler);

        let result2 = order_test().run_checked(vec_handler2);
        assert_eq!(result2, Ok(12));
    }

    #[test]
    fn test_stateful_partial_handler() {
        // Test that partial handlers can maintain state
        struct CountingHandler {
            count: usize,
        }

        impl PartialHandler<Op> for CountingHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(_)) => {
                        self.count += 1;
                        Some(Box::new(()))
                    }
                    Op::Logger(Logger::GetLogCount) => Some(Box::new(self.count)),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn counting_program() -> usize {
            let _: () = perform!(Logger::Info("First".to_string()));
            let _: () = perform!(Logger::Info("Second".to_string()));
            let _: () = perform!(Logger::Info("Third".to_string()));
            perform!(Logger::GetLogCount)
        }

        let handler = CountingHandler { count: 0 };
        let result = counting_program().run_checked(handler);
        assert_eq!(result, Ok(3));
    }

    #[test]
    fn test_result_error_propagation() {
        // Test that errors in effectful computations propagate correctly
        struct DivisionHandler;

        impl PartialHandler<Op> for DivisionHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Divide((a, b))) => {
                        if *b == 0 {
                            Some(Box::new(Err::<i32, String>("Division by zero".to_string())))
                        } else {
                            Some(Box::new(Ok::<i32, String>(a / b)))
                        }
                    }
                    _ => None,
                }
            }
        }

        #[effectful]
        fn safe_division() -> Result<i32, String> {
            let result: Result<i32, String> = perform!(Math::Divide((10, 0)));
            result
        }

        let handler = DivisionHandler;
        let result = safe_division().run_checked(handler);
        assert!(result.is_ok()); // run_checked succeeded
        assert!(result.unwrap().is_err()); // but the division failed
    }

    #[test]
    fn test_empty_vec_handler() {
        // Test that empty VecHandler declines everything
        #[effectful]
        fn simple_effect() -> i32 {
            perform!(Math::Add((1, 1)))
        }

        let empty_handler = VecHandler::<Op>::new();
        let result = simple_effect().run_checked(empty_handler);
        assert!(result.is_err());
    }

    #[test]
    fn test_handle_all_empty() {
        // Test handle_all with empty iterator
        #[effectful]
        fn simple_effect() -> i32 {
            perform!(Math::Add((2, 2)))
        }

        let empty_handler = VecHandler::<Op>::new();
        let result = simple_effect().run_checked(empty_handler);
        assert!(result.is_err());
    }

    #[test]
    fn test_variable_handler_chain() {
        // Test chaining multiple handlers together
        struct ConsoleHandler;
        impl PartialHandler<Op> for ConsoleHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::IO(IO::WriteString(s)) => {
                        println!("Console: {s}");
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        struct FileHandler;
        impl PartialHandler<Op> for FileHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::IO(IO::ReadString) => Some(Box::new("file content".to_string())),
                    _ => None,
                }
            }
        }

        struct LogHandler {
            count: i32,
        }
        impl PartialHandler<Op> for LogHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(msg)) => {
                        self.count += 1;
                        println!("[INFO] {msg}");
                        Some(Box::new(()))
                    }
                    Op::Logger(Logger::GetLogCount) => Some(Box::new(self.count as usize)),
                    _ => None,
                }
            }
        }

        #[effectful]
        fn three_handler_computation() -> String {
            let _: () = perform!(Logger::Info("Starting computation".to_string()));
            let _: () = perform!(IO::WriteString("Reading file...".to_string()));
            let content: String = perform!(IO::ReadString);
            let _: () = perform!(Logger::Info(format!("Read: {content}")));
            let count: usize = perform!(Logger::GetLogCount);
            format!("Completed with {count} log entries")
        }

        // Chain three handlers together using handle_all
        let result = three_handler_computation()
            .handle_all(vec![
                Box::new(ConsoleHandler) as Box<dyn PartialHandler<Op> + Send>,
                Box::new(FileHandler),
                Box::new(LogHandler { count: 0 }),
            ])
            .run_checked();

        assert_eq!(result.unwrap(), "Completed with 2 log entries");
    }

    #[test]
    fn test_handler_chain_with_total_handlers() {
        // Test mixing Handler and PartialHandler types
        #[effectful]
        fn mixed_computation() -> i32 {
            let a: i32 = perform!(Test::GetValue);
            let b: i32 = perform!(Math::Add((a, 10)));
            let _: () = perform!(Test::SetValue(b));
            b
        }

        // Create a combined handler that handles both Test and Math operations
        struct CombinedHandler {
            test_handler: TestHandler,
        }

        impl CombinedHandler {
            fn new(initial: i32) -> Self {
                Self {
                    test_handler: TestHandler::new(initial),
                }
            }
        }

        impl Handler<Op> for CombinedHandler {
            fn handle(&mut self, op: &Op) -> Box<dyn Any + Send> {
                match op {
                    Op::Test(_) => self.test_handler.handle(op),
                    Op::Math(Math::Add((a, b))) => Box::new(a + b),
                    _ => panic!("CombinedHandler cannot handle this operation: {op:?}"),
                }
            }
        }

        // Use the combined handler directly
        let result = mixed_computation().run_with(CombinedHandler::new(5));

        assert_eq!(result, 15);

        // Also test the checked version
        let result2 = mixed_computation().run_checked_with(CombinedHandler::new(5));

        assert_eq!(result2.unwrap(), 15);
    }

    #[test]
    fn test_unhandled_op_error_in_chain() {
        // Test that unhandled operations properly return errors
        #[effectful]
        fn unhandled_computation() -> i32 {
            let _: () = perform!(Logger::Info("This will work".to_string()));
            let x: i32 = perform!(Math::Add((5, 5))); // This won't be handled
            x
        }

        struct OnlyLoggerHandler;
        impl PartialHandler<Op> for OnlyLoggerHandler {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(msg)) => {
                        println!("[LOG] {msg}");
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        let result = unhandled_computation().run_checked(OnlyLoggerHandler);

        match result {
            Err(UnhandledOp(Op::Math(Math::Add((5, 5))))) => (),
            _ => panic!("Expected UnhandledOp error for Math::Add"),
        }
    }

    #[test]
    fn test_handle_all_alternative() {
        // Test handle_all as an alternative to chained handle calls
        struct Handler1;
        impl PartialHandler<Op> for Handler1 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        struct Handler2;
        impl PartialHandler<Op> for Handler2 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Multiply((a, b))) => Some(Box::new(a * b)),
                    _ => None,
                }
            }
        }

        struct Handler3;
        impl PartialHandler<Op> for Handler3 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(msg)) => {
                        println!("[INFO] {msg}");
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        #[effectful]
        fn computation() -> i32 {
            let _: () = perform!(Logger::Info("Starting".to_string()));
            let a: i32 = perform!(Math::Add((2, 3)));
            let b: i32 = perform!(Math::Multiply((a, 4)));
            b
        }

        // Use handle_all to attach all handlers at once
        let handlers: Vec<Box<dyn PartialHandler<Op> + Send>> =
            vec![Box::new(Handler1), Box::new(Handler2), Box::new(Handler3)];

        let result = computation().handle_all(handlers).run_checked();

        assert_eq!(result.unwrap(), 20); // (2 + 3) * 4 = 20
    }

    #[test]
    fn test_chained_handler_syntax() {
        // Test the .handle().handle().handle() chaining pattern
        struct Handler1;
        impl PartialHandler<Op> for Handler1 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Add((a, b))) => Some(Box::new(a + b)),
                    _ => None,
                }
            }
        }

        struct Handler2;
        impl PartialHandler<Op> for Handler2 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Math(Math::Multiply((a, b))) => Some(Box::new(a * b)),
                    _ => None,
                }
            }
        }

        struct Handler3;
        impl PartialHandler<Op> for Handler3 {
            fn maybe_handle(&mut self, op: &Op) -> Option<Box<dyn Any + Send>> {
                match op {
                    Op::Logger(Logger::Info(msg)) => {
                        // Just return unit, don't actually print
                        let _ = msg;
                        Some(Box::new(()))
                    }
                    _ => None,
                }
            }
        }

        #[effectful]
        fn chained_computation() -> i32 {
            let _: () = perform!(Logger::Info("Starting".to_string()));
            let sum: i32 = perform!(Math::Add((10, 20)));
            let product: i32 = perform!(Math::Multiply((sum, 2)));
            let _: () = perform!(Logger::Info("Done".to_string()));
            product
        }

        // Test chaining with empty initial vector
        let result = chained_computation()
            .handle_all(Vec::<Box<dyn PartialHandler<Op> + Send>>::new())
            .handle(Handler1)
            .handle(Handler2)
            .handle(Handler3)
            .run_checked();

        assert_eq!(result.unwrap(), 60); // (10 + 20) * 2 = 60

        // Test chaining starting with one handler
        let result = chained_computation()
            .handle_all([Handler1])
            .handle(Handler2)
            .handle(Handler3)
            .run_checked();

        assert_eq!(result.unwrap(), 60);

        // Test partial chain (missing logger handler)
        let result = chained_computation()
            .handle_all(Vec::<Box<dyn PartialHandler<Op> + Send>>::new())
            .handle(Handler1)
            .handle(Handler2)
            // Intentionally not adding Handler3
            .run_checked();

        // Should fail because Logger::Info is not handled
        assert!(result.is_err());
        match result {
            Err(UnhandledOp(Op::Logger(Logger::Info(_)))) => (),
            _ => panic!("Expected unhandled Logger::Info operation"),
        }
    }
}
