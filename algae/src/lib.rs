//! # Algae - Algebraic Effects for Rust
//!
//! Algae is a library for algebraic effects in Rust, providing a way to write effectful
//! computations in a composable and testable manner. Algebraic effects allow you to
//! separate the description of side effects from their implementation, making your code
//! more modular and easier to test.
//!
//! ## One-Shot (Linear) Effects
//!
//! Algae implements **one-shot (linear) algebraic effects**, where each effect operation
//! receives exactly one response and continuations are not captured for reuse. This design
//! provides several benefits:
//!
//! - **Simplicity**: Easier to understand and debug than multi-shot alternatives
//! - **Performance**: No continuation capture overhead
//! - **Predictability**: Linear control flow is easier to reason about
//! - **Rust-Friendly**: Aligns well with Rust's ownership model
//!
//! This covers the vast majority of real-world use cases including I/O, state management,
//! logging, error handling, and resource management.
//!
//! ## Core Concepts
//!
//! - **Effects**: Descriptions of operations that can be performed (e.g., "read a file", "log a message")
//! - **Handlers**: Implementations that define how effects are executed
//! - **Effectful Functions**: Functions that can perform effects using the `perform!` macro
//!
//! ## Quick Start
//!
//! ```rust,ignore
//! #![feature(coroutines, coroutine_trait, yield_expr)]
//! use algae::prelude::*;
//!
//! // Define your effects
//! effect! {
//!     Console::Print (String) -> ();
//!     Console::ReadLine -> String;
//! }
//!
//! // Write effectful functions
//! #[effectful]
//! fn greet_user() -> String {
//!     let _: () = perform!(Console::Print("What's your name?".to_string()));
//!     let name: String = perform!(Console::ReadLine);
//!     format!("Hello, {}!", name)
//! }
//!
//! // Implement handlers
//! struct MockConsole {
//!     responses: Vec<String>,
//!     index: std::cell::RefCell<usize>,
//! }
//!
//! impl Handler<Op> for MockConsole {
//!     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
//!         match op {
//!             Op::Console(Console::Print(msg)) => {
//!                 println!("[MOCK] {}", msg);
//!                 Box::new(())
//!             }
//!             Op::Console(Console::ReadLine) => {
//!                 let mut index = self.index.borrow_mut();
//!                 let response = self.responses.get(*index).cloned()
//!                     .unwrap_or_else(|| "default".to_string());
//!                 *index += 1;
//!                 Box::new(response)
//!             }
//!         }
//!     }
//! }
//!
//! // Run with handler
//! let handler = MockConsole {
//!     responses: vec!["Alice".to_string()],
//!     index: std::cell::RefCell::new(0),
//! };
//! let result = greet_user().handle(handler).run();
//! assert_eq!(result, "Hello, Alice!");
//! ```
//!
//! ## Features
//!
//! - **Type-safe effects**: Effects are statically typed and checked at compile time
//! - **Composable handlers**: Multiple effect families can be handled by a single handler
//! - **Testable**: Effects can be easily mocked for testing
//! - **Zero-cost abstractions**: Minimal runtime overhead
//! - **Rust coroutines**: Built on Rust's native coroutine support

#![feature(coroutines, coroutine_trait)]
use std::{
    any::Any,
    ops::{Coroutine, CoroutineState},
    pin::Pin,
};

/// An effect operation request paired with a slot for the handler's reply.
///
/// An `Effect` represents a single effectful operation that has been yielded from
/// an effectful computation. It contains the operation description (`op`) and a
/// slot where the handler can store the result of processing that operation.
///
/// ## One-Shot Semantics
///
/// Effects in algae are **one-shot (linear)**, meaning:
/// - Each effect receives exactly **one response** from the handler
/// - The effect is **consumed** when the reply is extracted
/// - **No continuation capture** - the computation cannot be rewound or replayed
/// - **Linear control flow** - effects execute once and continue forward
///
/// This design ensures predictable behavior and optimal performance while covering
/// the vast majority of practical use cases.
///
/// # Type Parameters
///
/// * `Op` - The type representing the effect operation. This is typically an enum
///   generated by the `effect!` macro that describes all possible operations.
///
/// # Fields
///
/// * `op` - The operation being requested (e.g., "read file", "log message")
/// * `reply` - A type-erased storage slot where the handler places the result (filled exactly once)
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// // Effects are typically created by the perform! macro and handled automatically
/// let mut effect = Effect::new(Test::GetValue);
/// effect.fill_boxed(Box::new(42i32));
/// let reply = effect.get_reply();
/// let value: i32 = reply.take();
/// assert_eq!(value, 42);
/// ```
pub struct Effect<Op: 'static> {
    /// The operation being requested
    pub op: Op,
    /// Storage for the handler's reply (filled by the handler)
    reply: Option<Box<dyn Any + Send>>,
}

/// A type-erased container for handler replies that can be safely extracted.
///
/// A `Reply` holds the result from a handler after it processes an effect operation.
/// The value is stored in a type-erased `Box<dyn Any + Send>` but can be safely
/// extracted with the correct type using the `take` method.
///
/// ## One-Shot Extraction
///
/// Consistent with algae's one-shot effect model, replies can only be extracted **once**.
/// The `take` method consumes the `Reply`, ensuring that each handler response is used
/// exactly once, maintaining linear control flow and preventing accidental reuse.
///
/// # Safety
///
/// The type safety is ensured by the effect system - handlers are expected to
/// return values of the correct type as specified in the effect definition.
/// Runtime type checking occurs during extraction to catch any mismatches.
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         Box::new(42i32)
/// #     }
/// # }
/// // Reply is typically created internally by the effect system
/// #[effectful]
/// fn example() -> i32 {
///     let value: i32 = perform!(Test::GetValue); // Creates and uses Reply internally
///     value
/// }
/// let result = example().handle(TestHandler).run();
/// assert_eq!(result, 42);
/// ```
pub struct Reply {
    /// Type-erased storage for the handler's response value
    value: Box<dyn Any + Send>,
}

impl<Op> Effect<Op> {
    /// Creates a new effect with the given operation and no reply.
    ///
    /// This is typically called by the `perform!` macro when an effectful
    /// computation yields an operation to be handled.
    ///
    /// # Arguments
    ///
    /// * `op` - The operation to be performed
    ///
    /// # Returns
    ///
    /// A new `Effect` with the specified operation and no reply value.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let effect = Effect::new(Test::GetValue);
    /// // Effect is now ready to be handled
    /// ```
    pub fn new(op: Op) -> Self { 
        Self { op, reply: None } 
    }
    
    /// Stores a pre-boxed reply value in this effect (one-shot only).
    ///
    /// This method is called by handlers to provide the result of processing
    /// the effect operation. The value must already be boxed as `Box<dyn Any + Send>`.
    ///
    /// ## One-Shot Semantics
    ///
    /// Consistent with algae's linear effect model, each effect can be filled with a reply
    /// **exactly once**. Attempting to fill an effect that already has a reply will panic,
    /// ensuring the one-shot invariant is maintained.
    ///
    /// # Arguments
    ///
    /// * `r` - The boxed reply value from the handler
    ///
    /// # Panics
    ///
    /// This method will panic if called on an effect that already has a reply, maintaining
    /// the one-shot (linear) semantics of algae's effect system.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let mut effect = Effect::new(Test::GetValue);
    /// effect.fill_boxed(Box::new(42i32));
    /// // Effect now contains the reply value
    /// ```
    pub fn fill_boxed(&mut self, r: Box<dyn Any + Send>) { 
        assert!(self.reply.is_none(), "reply filled twice");
        self.reply = Some(r);
    }
    
    /// Consumes the effect and extracts the reply value (one-shot consumption).
    ///
    /// This method retrieves the reply that was stored by the handler and
    /// wraps it in a `Reply` for type-safe extraction. The effect is consumed
    /// in the process, enforcing the one-shot semantics of algae's linear effect model.
    ///
    /// ## One-Shot Consumption
    ///
    /// This method takes ownership of the effect (`self`), ensuring that each effect
    /// reply can only be extracted once. This prevents accidental reuse and maintains
    /// the linear control flow guarantees of the effect system.
    ///
    /// # Returns
    ///
    /// A `Reply` containing the handler's response value.
    ///
    /// # Panics
    ///
    /// Panics if the effect has no reply (i.e., if `fill_boxed` was never called).
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// let mut effect = Effect::new(Test::GetValue);
    /// effect.fill_boxed(Box::new(42i32));
    /// let reply = effect.get_reply();
    /// let value: i32 = reply.take();
    /// assert_eq!(value, 42);
    /// ```
    pub fn get_reply(self) -> Reply {
        let reply_value = self.reply.expect("Effect has no reply");
        Reply {
            value: reply_value
        }
    }
}

impl Reply {
    /// Extracts the contained value with the specified type (one-shot extraction).
    ///
    /// This method performs a runtime type check to ensure the stored value
    /// matches the requested type `R`. If successful, it returns the value.
    /// If the types don't match, it panics with a descriptive error message.
    ///
    /// ## One-Shot Extraction
    ///
    /// This method consumes the `Reply` (takes `self` by value), enforcing algae's
    /// one-shot semantics. Each reply value can only be extracted once, preventing
    /// accidental reuse and maintaining linear control flow.
    ///
    /// # Type Parameters
    ///
    /// * `R` - The expected type of the contained value. Must implement `Any + Send`.
    ///
    /// # Returns
    ///
    /// The contained value of type `R`.
    ///
    /// # Panics
    ///
    /// Panics if the contained value is not of type `R`. The panic message
    /// includes both the expected type name and the actual type ID for debugging.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         Box::new(42i32)
    /// #     }
    /// # }
    /// // Reply is used internally when performing effects
    /// #[effectful]
    /// fn example() -> i32 {
    ///     let value: i32 = perform!(Test::GetValue); // take() called internally
    ///     value
    /// }
    /// let result = example().handle(TestHandler).run();
    /// assert_eq!(result, 42);
    /// ```
    pub fn take<R: Any + Send>(self) -> R {
        let type_id = (&*self.value as &dyn Any).type_id();
        match self.value.downcast::<R>() {
            Ok(val) => *val,
            Err(_) => {
                panic!("Type mismatch when taking reply: expected {}, got {:?}", 
                    std::any::type_name::<R>(),
                    type_id);
            }
        }
    }
}

/// Type alias for the complex coroutine type to improve readability.
///
/// This represents a pinned, boxed coroutine that:
/// - Takes `Option<Reply>` as resume argument (the reply from the previous effect)
/// - Returns `R` when the computation completes
/// - Yields `Effect<Op>` when an effect needs to be handled
type EffectCoroutine<R, Op> = Pin<Box<dyn Coroutine<Option<Reply>, Return = R, Yield = Effect<Op>>>>;

/// A wrapper around a coroutine that represents an effectful computation.
///
/// `Effectful<R, Op>` encapsulates a computation that may perform effects of type `Op`
/// and eventually produces a result of type `R`. The computation is represented as
/// a coroutine that yields effects to be handled and resumes with the handler's replies.
///
/// This is the core type returned by functions annotated with `#[effectful]`.
/// It provides methods for running the computation with handlers.
///
/// # Type Parameters
///
/// * `R` - The return type of the effectful computation
/// * `Op` - The type of effects that can be performed (typically an enum)
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
/// #     }
/// # }
/// #[effectful]
/// fn my_computation() -> i32 {
///     let value: i32 = perform!(Test::GetValue);
///     value * 2
/// }
///
/// let result = my_computation()
///     .handle(TestHandler)
///     .run();
/// assert_eq!(result, 84);
/// ```
pub struct Effectful<R, Op: 'static> {
    /// The underlying coroutine representing the effectful computation
    gen: EffectCoroutine<R, Op>,
}

impl<R, Op: 'static> Effectful<R, Op> {
    /// Creates a new effectful computation from a coroutine.
    ///
    /// This is typically called by the `#[effectful]` macro to wrap the generated
    /// coroutine in an `Effectful` type for easier handling.
    ///
    /// # Type Parameters
    ///
    /// * `G` - The coroutine type that implements the required traits
    ///
    /// # Arguments
    ///
    /// * `g` - The coroutine representing the effectful computation
    ///
    /// # Returns
    ///
    /// A new `Effectful` wrapper around the provided coroutine.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr, stmt_expr_attributes)]
    /// # use algae::prelude::*;
    /// # use std::pin::Pin;
    /// # effect! { Test::GetValue -> i32; }
    /// // This is typically done by the #[effectful] macro
    /// let coroutine = #[coroutine] |_: Option<Reply>| {
    ///     let effect = Effect::new(Test::GetValue);
    ///     let reply = yield effect;
    ///     let value: i32 = reply.unwrap().take();
    ///     value
    /// };
    ///
    /// let effectful = Effectful::new(coroutine);
    /// // Now ready to be run with a handler
    /// ```
    pub fn new<G>(g: G) -> Self
    where
        G: Coroutine<Option<Reply>, Return = R, Yield = Effect<Op>> + 'static,
    {
        Self { gen: Box::pin(g) }
    }

    /// Executes the effectful computation using a single handler.
    ///
    /// This method drives the coroutine to completion by handling each effect
    /// as it's yielded. When an effect is yielded, the handler processes it
    /// and the result is sent back to resume the coroutine.
    ///
    /// # Arguments
    ///
    /// * `h` - The handler that will process all effects
    ///
    /// # Returns
    ///
    /// The final result of the effectful computation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation().run_with(TestHandler);
    /// assert_eq!(result, 42);
    /// ```
    pub fn run_with<H: Handler<Op>>(mut self, mut h: H) -> R {
        // Start with None for the first call
        let mut resume_arg: Option<Reply> = None;
        
        loop {
            match self.gen.as_mut().resume(resume_arg) {
                CoroutineState::Complete(r) => return r,
                CoroutineState::Yielded(mut eff) => {
                    let reply_any = h.handle(&eff.op);
                    eff.fill_boxed(reply_any);
                    resume_arg = Some(eff.get_reply());
                }
            }
        }
    }

    /// Chains a handler with this effectful computation for fluent syntax.
    ///
    /// This method enables the fluent `.handle(...).run()` pattern by wrapping
    /// the effectful computation and handler in a `Handled` type. The computation
    /// is not executed until `run()` is called on the returned `Handled`.
    ///
    /// # Arguments
    ///
    /// * `h` - The handler to use for processing effects
    ///
    /// # Returns
    ///
    /// A `Handled` type that bundles the computation and handler together.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation()
    ///     .handle(TestHandler)
    ///     .run();
    /// assert_eq!(result, 42);
    /// ```
    pub fn handle<H: Handler<Op>>(self, h: H) -> Handled<R, Op, H> {
        Handled { eff: self, h }
    }
}

/// A bundled effectful computation and handler ready for execution.
///
/// `Handled` is an intermediate type returned by `Effectful::handle()` that
/// pairs an effectful computation with its handler. It provides a `run()`
/// method to execute the computation. This enables the fluent syntax:
/// `computation().handle(handler).run()`.
///
/// # Type Parameters
///
/// * `R` - The return type of the effectful computation
/// * `Op` - The type of effects that can be performed
/// * `H` - The handler type that processes the effects
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { Test::GetValue -> i32; }
/// # struct TestHandler;
/// # impl Handler<Op> for TestHandler {
/// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
/// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
/// #     }
/// # }
/// #[effectful]
/// fn computation() -> i32 {
///     perform!(Test::GetValue)
/// }
///
/// // .handle() returns a Handled<i32, Op, TestHandler>
/// let handled = computation().handle(TestHandler);
/// let result = handled.run(); // Execute the computation
/// assert_eq!(result, 42);
/// ```
pub struct Handled<R, Op: 'static, H: Handler<Op>> { 
    /// The effectful computation to execute
    eff: Effectful<R, Op>, 
    /// The handler that will process effects
    h: H 
}

impl<R, Op: 'static, H: Handler<Op>> Handled<R, Op, H> {
    /// Executes the bundled effectful computation with its handler.
    ///
    /// This is a convenience method that calls `run_with` on the effectful
    /// computation using the bundled handler.
    ///
    /// # Returns
    ///
    /// The final result of the effectful computation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Test::GetValue -> i32; }
    /// # struct TestHandler;
    /// # impl Handler<Op> for TestHandler {
    /// #     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    /// #         match op { Op::Test(Test::GetValue) => Box::new(42i32) }
    /// #     }
    /// # }
    /// #[effectful]
    /// fn computation() -> i32 {
    ///     perform!(Test::GetValue)
    /// }
    ///
    /// let result = computation()
    ///     .handle(TestHandler)
    ///     .run(); // This calls run()
    /// assert_eq!(result, 42);
    /// ```
    pub fn run(self) -> R { 
        self.eff.run_with(self.h) 
    }
}

/// Trait that all effect handlers must implement.
///
/// A handler defines how to process effect operations. When an effectful
/// computation yields an effect, the handler's `handle` method is called
/// with the operation, and it must return the appropriate response value.
///
/// The response is returned as `Box<dyn Any + Send>` to allow handlers to
/// return different types for different operations. Type safety is ensured
/// by the effect system - the `perform!` macro will extract the correct type.
///
/// # Type Parameters
///
/// * `Op` - The type of operations this handler can process
///
/// # Examples
///
/// ```rust,ignore
/// # #![feature(coroutines, coroutine_trait, yield_expr)]
/// # use algae::prelude::*;
/// # effect! { 
/// #     File::Read (String) -> String;
/// #     File::Write ((String, String)) -> ();
/// # }
/// use std::collections::HashMap;
///
/// struct FileHandler {
///     files: HashMap<String, String>,
/// }
///
/// impl Handler<Op> for FileHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::File(File::Read(filename)) => {
///                 let content = self.files.get(filename)
///                     .cloned()
///                     .unwrap_or_else(|| "".to_string());
///                 Box::new(content)
///             }
///             Op::File(File::Write((filename, content))) => {
///                 self.files.insert(filename.clone(), content.clone());
///                 Box::new(())
///             }
///         }
///     }
/// }
/// ```
///
/// # Thread Safety
///
/// The returned `Box<dyn Any + Send>` must be `Send` to allow handlers to
/// work across thread boundaries. This means the values you return must
/// implement `Send`.
///
/// # Type Safety
///
/// Although this method returns a type-erased value, type safety is maintained
/// by the effect system. The effect definitions specify what type each operation
/// should return, and the `perform!` macro will extract that specific type.
/// If there's a mismatch, the program will panic with a descriptive error.
pub trait Handler<Op> {
    /// Processes an effect operation and returns the result.
    ///
    /// This method is called by the effect runtime when an effectful computation
    /// yields an operation that needs to be handled. The handler examines the
    /// operation and returns an appropriate response value.
    ///
    /// # Arguments
    ///
    /// * `op` - The operation to be processed
    ///
    /// # Returns
    ///
    /// The result of processing the operation, boxed as `Box<dyn Any + Send>`.
    /// The type of the returned value should match what the effect definition
    /// specifies for this operation.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// # #![feature(coroutines, coroutine_trait, yield_expr)]
    /// # use algae::prelude::*;
    /// # effect! { Math::Add ((i32, i32)) -> i32; }
    /// struct MathHandler;
    ///
    /// impl Handler<Op> for MathHandler {
    ///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
    ///         match op {
    ///             Op::Math(Math::Add((a, b))) => {
    ///                 Box::new(a + b) // Returns i32 as specified
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    fn handle(&mut self, op: &Op) -> Box<dyn Any + Send>;
}

/// Convenience module that re-exports everything needed to use algae.
///
/// This module provides a single import point for all the essential types
/// and macros needed to work with algebraic effects. Users can simply
/// `use algae::prelude::*` to get started.
///
/// # Re-exported Items
///
/// ## Core Types
/// - [`Effect`] - Represents an effect operation with space for a reply
/// - [`Effectful`] - Wrapper around effectful computations  
/// - [`Handler`] - Trait for implementing effect handlers
/// - [`Reply`] - Container for handler response values
///
/// ## Macros (when "macros" feature is enabled)
/// - [`effect!`] - Macro for defining effect families and operations
/// - [`effectful`] - Attribute macro for marking functions as effectful
/// - [`perform!`] - Macro for performing effects within effectful functions
///
/// # Examples
///
/// ## With macros (default):
/// ```rust,ignore
/// #![feature(coroutines, coroutine_trait, yield_expr)]
/// use algae::prelude::*;
///
/// // Define effects
/// effect! {
///     Counter::Get -> i32;
///     Counter::Set (i32) -> ();
/// }
///
/// // Create effectful functions
/// #[effectful]
/// fn increment() -> i32 {
///     let current: i32 = perform!(Counter::Get);
///     let _: () = perform!(Counter::Set(current + 1));
///     current + 1
/// }
///
/// // Implement handlers
/// struct CounterHandler { value: i32 }
///
/// impl Handler<Op> for CounterHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::Counter(Counter::Get) => Box::new(self.value),
///             Op::Counter(Counter::Set(new_val)) => {
///                 self.value = *new_val;
///                 Box::new(())
///             }
///         }
///     }
/// }
///
/// // Run computations
/// let result = increment()
///     .handle(CounterHandler { value: 5 })
///     .run();
/// assert_eq!(result, 6);
/// ```
///
/// ## Without macros (manual approach):
/// When using algae without the "macros" feature, you need to define
/// your effect types and handlers manually using the core types.
pub mod prelude {
    pub use crate::{Effect, Effectful, Handler, Reply};
    
    #[cfg(feature = "macros")]
    pub use algae_macros::{effect, effectful, perform};
}

/// Helper macro for combining multiple root enums into one unified enum.
///
/// This macro allows you to merge effect operations from different modules
/// that use custom root enum names into a single root enum for easier handling.
///
/// # Syntax
///
/// ```ignore
/// combine_roots!(pub Op = module_a::ConsoleOp, module_b::FileOp, module_c::NetOp);
/// ```
///
/// This generates:
/// - A new enum with the specified name containing all the other enums as variants
/// - `From` implementations to convert each source enum to the combined enum
///
/// # Example
///
/// ```ignore
/// mod console {
///     use algae::prelude::*;
///     effect! {
///         root ConsoleOp;
///         Console::Print (String) -> ();
///         Console::ReadLine -> String;
///     }
/// }
///
/// mod file {
///     use algae::prelude::*;
///     effect! {
///         root FileOp;
///         File::Read (String) -> String;
///         File::Write ((String, String)) -> ();
///     }
/// }
///
/// // Combine them into a unified root enum
/// combine_roots!(pub Op = console::ConsoleOp, file::FileOp);
///
/// // Now you can write handlers for the unified Op enum
/// struct UnifiedHandler;
/// impl Handler<Op> for UnifiedHandler {
///     fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
///         match op {
///             Op::ConsoleOp(console_op) => {
///                 // Handle console operations
///             }
///             Op::FileOp(file_op) => {
///                 // Handle file operations  
///             }
///         }
///     }
/// }
/// ```
#[macro_export]
macro_rules! combine_roots {
    ( $vis:vis $root:ident = $( $path:ident ),+ $(,)? ) => {
        #[derive(Debug)]
        $vis enum $root { 
            $( $path($path) ),+ 
        }

        $(
            impl From<$path> for $root { 
                fn from(f: $path) -> Self { 
                    $root::$path(f) 
                } 
            }
        )+
        
        // Note: Default implementation is not automatically generated
        // Users should implement Default manually if needed, as it's unclear
        // which variant should be the default when combining multiple enums
    };
}

#[cfg(all(test, feature = "macros"))]
mod tests {
    use crate as algae;
    use algae::prelude::*;
    use std::collections::HashMap;

    // Define test effects for comprehensive testing
    effect! {
        Test::GetValue -> i32;
        Test::SetValue (i32) -> ();
        
        Math::Add ((i32, i32)) -> i32;
        Math::Multiply ((i32, i32)) -> i32;
        Math::Divide ((i32, i32)) -> Result<i32, String>;
        
        IO::ReadString -> String;
        IO::WriteString (String) -> ();
        IO::ReadNumber -> i32;
        
        Logger::Info (String) -> ();
        Logger::Error (String) -> ();
        Logger::GetLogCount -> usize;
    }

    // Basic state handler for simple tests
    struct TestHandler {
        value: i32,
    }

    impl TestHandler {
        fn new(initial: i32) -> Self {
            Self { value: initial }
        }
    }

    impl Handler<Op> for TestHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Test(Test::GetValue) => Box::new(self.value),
                Op::Test(Test::SetValue(new_val)) => {
                    self.value = *new_val;
                    Box::new(())
                }
                _ => panic!("TestHandler cannot handle this operation: {op:?}")
            }
        }
    }

    // Math operations handler
    struct MathHandler;

    impl Handler<Op> for MathHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Math(Math::Add((a, b))) => Box::new(a + b),
                Op::Math(Math::Multiply((a, b))) => Box::new(a * b),
                Op::Math(Math::Divide((a, b))) => {
                    if *b == 0 {
                        Box::new(Err::<i32, String>("Division by zero".to_string()))
                    } else {
                        Box::new(Ok::<i32, String>(a / b))
                    }
                }
                _ => panic!("MathHandler cannot handle this operation: {op:?}")
            }
        }
    }

    // Mock IO handler with predefined responses
    struct MockIOHandler {
        string_responses: Vec<String>,
        number_responses: Vec<i32>,
        string_index: usize,
        number_index: usize,
        written_strings: Vec<String>,
    }

    impl MockIOHandler {
        fn new(string_responses: Vec<String>, number_responses: Vec<i32>) -> Self {
            Self {
                string_responses,
                number_responses,
                string_index: 0,
                number_index: 0,
                written_strings: Vec::new(),
            }
        }
        
        #[allow(dead_code)]
        fn written_strings(&self) -> &[String] {
            &self.written_strings
        }
    }

    impl Handler<Op> for MockIOHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::IO(IO::ReadString) => {
                    let response = if self.string_index < self.string_responses.len() {
                        self.string_responses[self.string_index].clone()
                    } else {
                        "default".to_string()
                    };
                    self.string_index += 1;
                    Box::new(response)
                }
                Op::IO(IO::WriteString(s)) => {
                    self.written_strings.push(s.clone());
                    Box::new(())
                }
                Op::IO(IO::ReadNumber) => {
                    let response = if self.number_index < self.number_responses.len() {
                        self.number_responses[self.number_index]
                    } else {
                        0
                    };
                    self.number_index += 1;
                    Box::new(response)
                }
                _ => panic!("MockIOHandler cannot handle this operation: {op:?}")
            }
        }
    }

    // Logging handler that tracks log calls
    struct LoggingHandler {
        logs: Vec<(String, String)>, // (level, message)
    }

    impl LoggingHandler {
        fn new() -> Self {
            Self { logs: Vec::new() }
        }
        
        #[allow(dead_code)]
        fn get_logs(&self) -> &[(String, String)] {
            &self.logs
        }
    }

    impl Handler<Op> for LoggingHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Logger(Logger::Info(msg)) => {
                    self.logs.push(("INFO".to_string(), msg.clone()));
                    Box::new(())
                }
                Op::Logger(Logger::Error(msg)) => {
                    self.logs.push(("ERROR".to_string(), msg.clone()));
                    Box::new(())
                }
                Op::Logger(Logger::GetLogCount) => {
                    Box::new(self.logs.len())
                }
                _ => panic!("LoggingHandler cannot handle this operation: {op:?}")
            }
        }
    }

    // Combined handler for multiple effect types
    struct CombinedTestHandler {
        test_handler: TestHandler,
        math_handler: MathHandler,
        io_handler: MockIOHandler,
        logger_handler: LoggingHandler,
    }

    impl CombinedTestHandler {
        fn new(initial_value: i32, string_responses: Vec<String>, number_responses: Vec<i32>) -> Self {
            Self {
                test_handler: TestHandler::new(initial_value),
                math_handler: MathHandler,
                io_handler: MockIOHandler::new(string_responses, number_responses),
                logger_handler: LoggingHandler::new(),
            }
        }
        
        #[allow(dead_code)]
        fn get_written_strings(&self) -> &[String] {
            self.io_handler.written_strings()
        }
        
        #[allow(dead_code)]
        fn get_logs(&self) -> &[(String, String)] {
            self.logger_handler.get_logs()
        }
    }

    impl Handler<Op> for CombinedTestHandler {
        fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
            match op {
                Op::Test(_) => self.test_handler.handle(op),
                Op::Math(_) => self.math_handler.handle(op),
                Op::IO(_) => self.io_handler.handle(op),
                Op::Logger(_) => self.logger_handler.handle(op),
            }
        }
    }

    // Test effectful functions
    #[effectful]
    fn test_computation() -> i32 {
        let current: i32 = perform!(Test::GetValue);
        let _: () = perform!(Test::SetValue(current * 2));
        let doubled: i32 = perform!(Test::GetValue);
        doubled + 10
    }

    #[effectful]
    fn math_computation() -> i32 {
        let sum: i32 = perform!(Math::Add((5, 3)));
        let product: i32 = perform!(Math::Multiply((sum, 2)));
        let result: Result<i32, String> = perform!(Math::Divide((product, 4)));
        result.unwrap_or(-1)
    }

    #[effectful]
    fn io_program() -> String {
        let _: () = perform!(IO::WriteString("Enter name:".to_string()));
        let name: String = perform!(IO::ReadString);
        let _: () = perform!(IO::WriteString("Enter age:".to_string()));
        let age: i32 = perform!(IO::ReadNumber);
        format!("{name} is {age} years old")
    }

    #[effectful]
    fn logging_program() -> usize {
        let _: () = perform!(Logger::Info("Starting program".to_string()));
        let _: () = perform!(Logger::Info("Processing data".to_string()));
        let _: () = perform!(Logger::Error("Something went wrong".to_string()));
        let count: usize = perform!(Logger::GetLogCount);
        count
    }

    #[effectful]
    fn complex_program() -> String {
        // Log start
        let _: () = perform!(Logger::Info("Complex program started".to_string()));
        
        // Get initial state
        let initial: i32 = perform!(Test::GetValue);
        
        // Do some math
        let doubled: i32 = perform!(Math::Multiply((initial, 2)));
        let _: () = perform!(Test::SetValue(doubled));
        
        // Read input
        let _: () = perform!(IO::WriteString("Enter multiplier:".to_string()));
        let multiplier: i32 = perform!(IO::ReadNumber);
        
        // More math
        let result: i32 = perform!(Math::Multiply((doubled, multiplier)));
        
        // Log result
        let _: () = perform!(Logger::Info(format!("Result calculated: {result}")));
        
        format!("Final result: {result}")
    }

    #[effectful]
    fn nested_effects() -> i32 {
        fn inner_computation() -> Effectful<i32, Op> {
            inner_effectful()
        }
        
        #[effectful]
        fn inner_effectful() -> i32 {
            let value: i32 = perform!(Test::GetValue);
            perform!(Math::Add((value, 5)))
        }
        
        let base: i32 = perform!(Test::GetValue);
        let _: () = perform!(Test::SetValue(base + 1));
        let inner_result: i32 = inner_computation().handle(CombinedTestHandler::new(10, vec![], vec![])).run();
        perform!(Math::Add((base, inner_result)))
    }

    #[effectful]
    fn error_handling_program() -> Result<i32, String> {
        let _: () = perform!(Logger::Info("Testing error handling".to_string()));
        let result: Result<i32, String> = perform!(Math::Divide((10, 0)));
        match result {
            Ok(val) => {
                let _: () = perform!(Logger::Info(format!("Division successful: {val}")));
                Ok(val)
            }
            Err(err) => {
                let _: () = perform!(Logger::Error(format!("Division failed: {err}")));
                Err(err)
            }
        }
    }

    // Basic functionality tests
    #[test]
    fn test_basic_effects() {
        let result = test_computation()
            .handle(TestHandler::new(5))
            .run();
        
        assert_eq!(result, 20); // (5 * 2) + 10 = 20
    }

    #[test]
    fn test_different_initial_values() {
        let result = test_computation()
            .handle(TestHandler::new(3))
            .run();
        
        assert_eq!(result, 16); // (3 * 2) + 10 = 16
    }

    #[test]
    fn test_math_operations() {
        let result = math_computation()
            .handle(MathHandler)
            .run();
        
        assert_eq!(result, 4); // (5 + 3) * 2 / 4 = 4
    }

    #[test]
    fn test_io_operations() {
        let result = io_program()
            .handle(MockIOHandler::new(
                vec!["Alice".to_string()],
                vec![25]
            ))
            .run();
        
        assert_eq!(result, "Alice is 25 years old");
    }

    #[test]
    fn test_logging_operations() {
        let handler = LoggingHandler::new();
        let result = logging_program()
            .handle(handler)
            .run();
        
        assert_eq!(result, 3);
        // Note: handler is moved into the effectful computation, so we can't inspect its logs afterwards
    }

    #[test]
    fn test_combined_handler() {
        let handler = CombinedTestHandler::new(5, vec!["test".to_string()], vec![3]);
        let result = complex_program()
            .handle(handler)
            .run();
        
        assert_eq!(result, "Final result: 30"); // 5 * 2 * 3 = 30
        // Note: handler is moved into the effectful computation
    }

    #[test]
    fn test_error_handling() {
        let handler = CombinedTestHandler::new(0, vec![], vec![]);
        let result = error_handling_program()
            .handle(handler)
            .run();
        
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero");
        // Note: handler is moved into the effectful computation
    }

    #[test]
    fn test_multiple_handler_calls() {
        let result1 = test_computation()
            .handle(TestHandler::new(1))
            .run();
        let result2 = test_computation()
            .handle(TestHandler::new(2))
            .run();
        let result3 = test_computation()
            .handle(TestHandler::new(3))
            .run();
        
        assert_eq!(result1, 12); // (1 * 2) + 10 = 12
        assert_eq!(result2, 14); // (2 * 2) + 10 = 14
        assert_eq!(result3, 16); // (3 * 2) + 10 = 16
    }

    #[test]
    fn test_zero_effects() {
        #[effectful]
        fn no_effects() -> i32 {
            42
        }
        
        let result = no_effects()
            .handle(TestHandler::new(0))
            .run();
        
        assert_eq!(result, 42);
    }

    #[test]
    fn test_single_effect() {
        #[effectful]
        fn single_effect() -> i32 {
            perform!(Test::GetValue)
        }
        
        let result = single_effect()
            .handle(TestHandler::new(99))
            .run();
        
        assert_eq!(result, 99);
    }

    #[test]
    fn test_many_effects() {
        #[effectful]
        fn many_effects() -> i32 {
            let mut sum = 0;
            for i in 1..=10 {
                let _: () = perform!(Test::SetValue(i));
                let val: i32 = perform!(Test::GetValue);
                sum += val;
            }
            sum
        }
        
        let result = many_effects()
            .handle(TestHandler::new(0))
            .run();
        
        assert_eq!(result, 55); // 1+2+3+...+10 = 55
    }

    #[test]
    fn test_different_return_types() {
        #[effectful]
        fn return_string() -> String {
            let val: i32 = perform!(Test::GetValue);
            format!("Value is {val}")
        }
        
        #[effectful]
        fn return_bool() -> bool {
            let val: i32 = perform!(Test::GetValue);
            val > 5
        }
        
        #[effectful]
        fn return_option() -> Option<i32> {
            let val: i32 = perform!(Test::GetValue);
            if val > 0 { Some(val) } else { None }
        }
        
        let string_result = return_string()
            .handle(TestHandler::new(42))
            .run();
        assert_eq!(string_result, "Value is 42");
        
        let bool_result = return_bool()
            .handle(TestHandler::new(10))
            .run();
        assert!(bool_result);
        
        let option_result = return_option()
            .handle(TestHandler::new(-1))
            .run();
        assert_eq!(option_result, None);
    }

    #[test]
    fn test_handler_state_persistence() {
        #[effectful]
        fn increment_twice() -> (i32, i32) {
            let first: i32 = perform!(Test::GetValue);
            let _: () = perform!(Test::SetValue(first + 1));
            let second: i32 = perform!(Test::GetValue);
            let _: () = perform!(Test::SetValue(second + 1));
            let third: i32 = perform!(Test::GetValue);
            (first, third)
        }
        
        let result = increment_twice()
            .handle(TestHandler::new(10))
            .run();
        
        assert_eq!(result, (10, 12));
    }

    // Edge case tests
    #[test]
    fn test_effect_with_unit_return() {
        #[effectful]
        fn unit_return() -> () {
            let _: () = perform!(Test::SetValue(42));
        }
        
        unit_return()
            .handle(TestHandler::new(0))
            .run();
    }

    #[test]
    fn test_complex_data_types() {
        effect! {
            Complex::GetVector -> Vec<i32>;
            Complex::GetMap -> HashMap<String, i32>;
        }
        
        struct ComplexHandler;
        
        impl Handler<Op> for ComplexHandler {
            fn handle(&mut self, op: &Op) -> Box<dyn std::any::Any + Send> {
                match op {
                    Op::Complex(Complex::GetVector) => Box::new(vec![1, 2, 3, 4, 5]),
                    Op::Complex(Complex::GetMap) => {
                        let mut map = HashMap::new();
                        map.insert("a".to_string(), 1);
                        map.insert("b".to_string(), 2);
                        Box::new(map)
                    }
                }
            }
        }
        
        #[effectful]
        fn complex_data() -> (Vec<i32>, HashMap<String, i32>) {
            let vec: Vec<i32> = perform!(Complex::GetVector);
            let map: HashMap<String, i32> = perform!(Complex::GetMap);
            (vec, map)
        }
        
        let (vec, map) = complex_data()
            .handle(ComplexHandler)
            .run();
        
        assert_eq!(vec, vec![1, 2, 3, 4, 5]);
        assert_eq!(map.get("a"), Some(&1));
        assert_eq!(map.get("b"), Some(&2));
    }

    // ============================================================================
    // Custom Root Enum Tests
    // ============================================================================

    mod custom_root_tests {
        use super::*;

        // Test effect with custom root name
        effect! {
            root CustomOp;
            Custom::GetValue -> i32;
            Custom::SetValue (i32) -> ();
        }

        // Another effect with different custom root name
        effect! {
            root AnotherOp;
            Another::GetString -> String;
            Another::SetString (String) -> ();
        }

        struct CustomHandler {
            value: i32,
        }

        impl Handler<CustomOp> for CustomHandler {
            fn handle(&mut self, op: &CustomOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    CustomOp::Custom(Custom::GetValue) => Box::new(self.value),
                    CustomOp::Custom(Custom::SetValue(val)) => {
                        self.value = *val;
                        Box::new(())
                    }
                }
            }
        }

        struct AnotherHandler {
            text: String,
        }

        impl Handler<AnotherOp> for AnotherHandler {
            fn handle(&mut self, op: &AnotherOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    AnotherOp::Another(Another::GetString) => Box::new(self.text.clone()),
                    AnotherOp::Another(Another::SetString(text)) => {
                        self.text = text.clone();
                        Box::new(())
                    }
                }
            }
        }

        #[test]
        fn test_custom_root_basic() {
            fn test_computation() -> algae::Effectful<i32, CustomOp> {
                algae::Effectful::new(#[coroutine] move |mut _reply: Option<algae::Reply>| {
                    // Get current value
                    let current: i32 = {
                        let effect = algae::Effect::new(Custom::GetValue.into());
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<i32>()
                    };

                    // Set new value
                    {
                        let effect = algae::Effect::new(Custom::SetValue(current + 10).into());
                        let reply_opt = yield effect;
                        let _: () = reply_opt.unwrap().take::<()>();
                    }

                    // Get updated value
                    let updated: i32 = {
                        let effect = algae::Effect::new(Custom::GetValue.into());
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<i32>()
                    };

                    updated
                })
            }

            let result = test_computation()
                .handle(CustomHandler { value: 5 })
                .run();

            assert_eq!(result, 15);
        }

        #[test]
        fn test_another_custom_root() {
            fn string_computation() -> algae::Effectful<String, AnotherOp> {
                algae::Effectful::new(#[coroutine] move |mut _reply: Option<algae::Reply>| {
                    // Get current string
                    let current: String = {
                        let effect = algae::Effect::new(Another::GetString.into());
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<String>()
                    };

                    // Set new string
                    {
                        let effect = algae::Effect::new(Another::SetString(format!("{} world!", current)).into());
                        let reply_opt = yield effect;
                        let _: () = reply_opt.unwrap().take::<()>();
                    }

                    // Get updated string
                    let updated: String = {
                        let effect = algae::Effect::new(Another::GetString.into());
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<String>()
                    };

                    updated
                })
            }

            let result = string_computation()
                .handle(AnotherHandler { text: "Hello".to_string() })
                .run();

            assert_eq!(result, "Hello world!");
        }

        // Test the combine_roots! macro
        algae::combine_roots!(CombinedOp = CustomOp, AnotherOp);

        struct CombinedHandler {
            custom: CustomHandler,
            another: AnotherHandler,
        }

        impl Handler<CombinedOp> for CombinedHandler {
            fn handle(&mut self, op: &CombinedOp) -> Box<dyn std::any::Any + Send> {
                match op {
                    CombinedOp::CustomOp(custom_op) => self.custom.handle(custom_op),
                    CombinedOp::AnotherOp(another_op) => self.another.handle(another_op),
                }
            }
        }

        #[test]
        fn test_combine_roots() {
            fn combined_computation() -> algae::Effectful<String, CombinedOp> {
                algae::Effectful::new(#[coroutine] move |mut _reply: Option<algae::Reply>| {
                    // Use custom effect
                    let value: i32 = {
                        let effect = algae::Effect::new(CombinedOp::CustomOp(Custom::GetValue.into()));
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<i32>()
                    };

                    // Use another effect
                    let text: String = {
                        let effect = algae::Effect::new(CombinedOp::AnotherOp(Another::GetString.into()));
                        let reply_opt = yield effect;
                        reply_opt.unwrap().take::<String>()
                    };

                    format!("{}: {}", text, value)
                })
            }

            let result = combined_computation()
                .handle(CombinedHandler {
                    custom: CustomHandler { value: 42 },
                    another: AnotherHandler { text: "Test".to_string() },
                })
                .run();

            assert_eq!(result, "Test: 42");
        }
    }

    // ============================================================================
    // One-Shot Guarantee Tests
    // ============================================================================

    #[test]
    fn test_one_shot_effect_fill() {
        // Test that filling an effect twice panics (enforcing one-shot guarantee)
        let mut effect = Effect::new(Test::GetValue);
        
        // First fill should succeed
        effect.fill_boxed(Box::new(42i32));
        
        // Second fill should panic
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            effect.fill_boxed(Box::new(24i32));
        }));
        
        assert!(result.is_err(), "Expected panic when filling effect twice");
        
        // The panic message should contain our assertion text
        if let Err(panic_payload) = result {
            if let Some(panic_str) = panic_payload.downcast_ref::<&str>() {
                assert!(panic_str.contains("reply filled twice"), 
                    "Panic message should mention 'reply filled twice', got: {}", panic_str);
            } else if let Some(panic_string) = panic_payload.downcast_ref::<String>() {
                assert!(panic_string.contains("reply filled twice"), 
                    "Panic message should mention 'reply filled twice', got: {}", panic_string);
            }
        }
    }

    #[test]
    fn test_one_shot_effect_get_reply_without_fill() {
        // Test that get_reply panics when no reply has been filled
        let effect = Effect::new(Test::GetValue);
        
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _ = effect.get_reply();
        }));
        
        assert!(result.is_err(), "Expected panic when calling get_reply on unfilled effect");
    }

    #[test]
    fn test_one_shot_reply_take_wrong_type() {
        // Test that Reply::take panics with wrong type (additional safety check)
        let mut effect = Effect::new(Test::GetValue);
        effect.fill_boxed(Box::new(42i32));
        
        let reply = effect.get_reply();
        
        // Try to take with wrong type should panic
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            let _: String = reply.take();
        }));
        
        assert!(result.is_err(), "Expected panic when taking reply with wrong type");
    }

    #[test]
    fn test_one_shot_fill_and_get_success() {
        // Test the happy path: fill once, get once - should work perfectly
        let mut effect = Effect::new(Test::GetValue);
        
        // Fill with a value
        effect.fill_boxed(Box::new(42i32));
        
        // Get reply and extract value
        let reply = effect.get_reply();
        let value: i32 = reply.take();
        
        assert_eq!(value, 42);
    }
}